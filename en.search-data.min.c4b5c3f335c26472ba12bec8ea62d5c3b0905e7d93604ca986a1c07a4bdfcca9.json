[{"id":0,"href":"/docs/js/","title":"JS笔记","section":"Docs","content":"\rJS笔记，等待完善ing\r#\r"},{"id":1,"href":"/docs/vue/note1/","title":"Vue响应式原理","section":"Vue笔记","content":"\rVue2\r#\rhttps://blog.csdn.net/weixin_58032613/article/details/122735346 https://blog.csdn.net/qq_41645323/article/details/123324680 vue中数据的双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。 数据劫持 通过Object.defineProperty()实现。 具体步骤：\n需要observer(观察者)对数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter。这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。 compile(模板解析器)解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 Watcher(订阅者)是Observer和Compile之间通信的桥梁，主要做的事情是: 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -\u0026gt; 视图更新；视图交互变化(input) -\u0026gt; 数据model变更的双向绑定效果。 Vue3 的变化\r#\r使用proxy代替defineProperty。 defineProperty：直接在一个对象上定义新的属性或修改现有的属性，并返回对象。无法监听对象或数组新增、删除的元素。Vue2 相应解决方案：针对常用数组原型方法push、pop、shift、unshift、splice、sort、reverse进行了hack处理；提供Vue.set监听对象/数组新增属性。对象的新增/删除响应，还可以new个新对象，新增则合并新属性和旧对象；删除则将删除属性后的对象深拷贝给新对象。 proxy：创建对象的代理，从而实现基本操作的拦截和自定义操作。关注对象整体，不关心里面有什么属性。\nVue2 为什么不能检测数组变动\r#\rhttps://segmentfault.com/a/1190000015783546\n监听数组\r#\rvue 能够监听数组变化的场景 vue 无法监听数组变化的场景 通过赋值的形式改变正在被监听的数组 通过数组索引改变数组元素的值 通过 splice(index, num, val) 的形式改变正在被监听的数组 改变数组的长度 通过数组的 push 的形式改变正在被监听的数组 无法监听数组变化的解决方案：\nthis.$set(arr, index, newVal)； 通过 splice(index，num，val)； 使用临时变量作为中转，重新赋值数组； 监听对象\r#\rvue 能够监听对象变化的场景 vue 无法监听对象变化的场景 直接赋值：watchObj = {name:\u0026ldquo;zyk\u0026rdquo;} 对象的增加、删除、修改无法被vue监听到 无法监听对象变化的解决方案：\n使用 this.$set(object, key, value)（vue 无法监听 this.$set 修改原有属性） 使用 Object.assign()，直接赋值 "},{"id":2,"href":"/docs/%E7%BD%91%E7%BB%9C/note1/","title":"前端跨域问题","section":"网络笔记","content":"\r跨域\r#\r跨域是指一个域下的文档或脚本去请求另一个域下的资源。通常说的跨域是指浏览器不能执行其他网站的脚本。它是浏览器同源策略造成的，是浏览器对JS实施的安全限制。\n同源策略\r#\r它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。同源策略限制以下行为：\nCookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送 三种思路\r#\r解除浏览器的跨域限制 发送JSON请求而不是xhr请求 修改服务器端（CORS） 解决方案\r#\rvue.config.js中proxy（代理，将浏览器的请求转发到服务器）\r#\r首先浏览器是禁止跨域的，但是服务端不禁止，在本地运行 npm run dev 等命令时实际上是用 node 运行了一个服务器，因此 proxyTable 实际上是将请求发给自己的服务器，再由服务器转发给后台服务器，做了一层代理。vue的proxyTable用的是http-proxy-middleware中间件, 因此不会出现跨域问题。\nCORS（第三种思路）\r#\r跨域资源共享 CORS 详解 - 阮一峰的网络日志\nJSONP（第二种思路）\r#\r利用script标签的src属性请求资源，缺点是只支持get请求。\nmac设置Chrome跨域（第一种思路）\r#\r原理：禁止浏览器进行跨域检查\n打开终端 运行命令：open -n /Applications/Google\\ Chrome.app/ \u0026ndash;args \u0026ndash;disable-web-security \u0026ndash;user-data-dir=/Users/zhongan/Documents/MyChromeDevUserData "},{"id":3,"href":"/docs/js/note2/","title":"手写函数","section":"JS笔记","content":"\rJS实现链表操作\r#\r// 定义节点 class Node { constructor(v) { this.value = v; this.next = null; } } // 创建链表 function createList(arr) { let list = new Node(null); let p = list; for (let data of arr) { p.next = new Node(data); p = p.next; } return list; } // 遍历链表 function traverseList(L) { let p = L.next; while(p) { console.log(p.value); p = p.next; } } // 获取链表长度 function getLen(L) { let res = 0; let p = L.next; while(p) { res += 1; p = p.next; } return res; } // 获取第i个元素值 function getElement(L, i) { let con = 0; let p = L.next; while(p) { con += 1; if (con === i) return p.value; p = p.next; } return null; } // 获取倒数第i个元素值 function getLastElement(L, i) { let p = L.next; let res = L.next; let dif = 0; while(p) { dif += 1; p = p.next; if(dif \u0026gt; i) res = res.next; } if (dif \u0026lt; i) return null; return res.value; } // 插入节点 function insertNode(L, position, value) { let p = L; let con = 0; while(p) { if (con === position) { let tmp = p.next; p.next = new Node(value); p.next.next = tmp; return true; } p = p.next; con += 1; } return false; } // 删除节点 function deleteNode(L, position) { let con = 0; let p = L.next; let prev = L; while(p) { if (con === position) prev.next = p.next; prev = prev.next; p = p.next; con += 1; } } // 有序链表合并 function mergeList(L1, L2) { let newL = new Node(null); let L = newL; let p = L1.next; let q = L2.next; while(p \u0026amp;\u0026amp; q) { if (p.value \u0026lt; q.value) { L.next = new Node(p.value); p = p.next; } else { L.next = new Node(q.value); q = q.next; } L = L.next; } while(p) { L.next = new Node(p.value); L = L.next; p = p.next; } while(q) { L.next = new Node(q.value); L = L.next; q = q.next; } return newL; } // 有序链表交集 function insertList(L1, L2) { let newL = new Node(null); let L = newL; let p = L1.next; let q = L2.next; while(p \u0026amp;\u0026amp; q) { if (p.value === q.value) { L.next = new Node(p.value); L = L.next; p = p.next; q = q.next; } else { if (p.value \u0026lt; q.value) { p = p.next; } else { q = q.next; } } } return newL; } let L = createList([1,2,3]); traverseList(\u0026#39;遍历链表\u0026#39;, L); console.log(\u0026#39;链表长度：\u0026#39;, getLen(L)); console.log(\u0026#39;第一个元素\u0026#39;, getElement(L, 1)); console.log(\u0026#39;第二个元素\u0026#39;, getElement(L, 2)); console.log(\u0026#39;第三个元素\u0026#39;, getElement(L, 3)); console.log(\u0026#39;第四个元素\u0026#39;, getElement(L, 4)); console.log(\u0026#39;倒数第一个元素\u0026#39;, getLastElement(L, 1)); console.log(\u0026#39;倒数第二个元素\u0026#39;, getLastElement(L, 2)); console.log(\u0026#39;倒数第三个元素\u0026#39;, getLastElement(L, 3)); console.log(\u0026#39;倒数第四个元素\u0026#39;, getLastElement(L, 4)); console.log(\u0026#39;倒数第四个元素\u0026#39;, getLastElement(L, 5)); // insertNode(L, 0, 10); // traverseList(L); // deleteNode(L, 1); // traverseList(L); let L2 = createList([1,3,6]); let newL = mergeList(L, L2); traverseList(newL); let newL1 = insertList(L, L2); traverseList(newL1); 数组拍平\r#\rfunction flat(arr, level) { if (level === 0) return [...arr]; let res = []; for (let a of arr) { if (Array.isArray(a)) { res = res.concat(flat(a, level - 1)); } else { res.push(a); } } return res; } console.log(flat([1, 2, [3, [4, 5]]], 0)); console.log(flat([1, 2, [3, [4, 5]]], 1)); console.log(flat([1, 2, [3, [4, 5]]], 2)); console.log(flat([1, 2, [3, [4, 5]]], 3)); JS创建二维数组\r#\r// 方法一 const arr = new Array(2).fill(0).map(() =\u0026gt; new Array(2).fill(0)); arr[0][0] = 1; // 正确 [ [ 1, 0 ], [ 0, 0 ] ] // 方法二(类似的for循环) const arr1 = new Array(); for(let i = 0; i \u0026lt; n; i++) { arr1.push([]); } JS字符串转数字\r#\r// 1. parseInt() 和 Number.parseInt() // 规则： // 1.忽略字符串前面的空格，直到找到第一个非空字符 // 2.如果第一个非空字符不是数字或者正负号，则返回NaN // 3.如果第一个是数字字符，一直解析到第一个非数字字符 // 4.如果第一个是数字字符，能识别不同进制的整数格式 // 5.接受第二个参数，即转换时使用的基数 // 6.小数向下取整 console.log(parseInt(true)); console.log(parseInt(false)); console.log(parseInt(null)); console.log(parseInt(undefined)); console.log(parseInt(NaN)); console.log(parseInt(\u0026#39; 123\u0026#39;)); console.log(parseInt(\u0026#39; a123\u0026#39;)); console.log(parseInt(\u0026#39; 123 4\u0026#39;)); console.log(parseInt(\u0026#39; 0xF\u0026#39;)); //16进制 console.log(parseInt(\u0026#39; 070\u0026#39;, 8)); //8进制 console.log(parseInt(0b10)); //2进制 console.log(parseInt(\u0026#39; A\u0026#39;, 16)); //16进制 // 2.parseFloat() // 规则： // 1.忽略字符串前面的空格，直到找到第一个非空字符 // 2.如果第一个非空字符不是数字或者正负号，则返回NaN // 3.如果第一个是数字字符，一直解析到第一个非数字字符 // 4.字符串中第一个小数点有效，第二个小数点无效 // 5.只解析10进制，不接受第二个参数 console.log(parseFloat(\u0026#39;123\u0026#39;)); console.log(parseFloat(\u0026#39;123.2\u0026#39;)); console.log(parseFloat(\u0026#39;ab123.2\u0026#39;)); console.log(parseFloat(\u0026#39;0xF\u0026#39;)); // 3.Number()构造函数 // 会返回一个字面量值，转化规则： // 如果是Boolean值，true和false分别返回1或0。 // 如果是数字，只是单纯的传入和返回。 // 如果是null，则返回0。 // 如果是undefined返回NaN。 // 如果是字符串且字符串为空则返回零，忽略前导零。 // 如果是字符串且字符串为整数则返回整数，忽略前导零。 // 如果是字符串且字符串为浮点数则返回浮点数。 // 如果是字符串且字符串为16进制，转为10进制返回。 // 除以上格式返回NaN。 // 如果是对象，则调用对象的valueOf，按照前面的规则返回值，如果返回NaN，再调用toString()，按照前面的规则返回值。 console.log(Number(true)); console.log(Number(false)); console.log(Number(123)); console.log(Number(null)); console.log(Number(undefined)); console.log(Number(NaN)); console.log(Number(\u0026#39;\u0026#39;)); console.log(Number(\u0026#39;123\u0026#39;)); console.log(Number(\u0026#39;123.1\u0026#39;)); console.log(Number(\u0026#39;0xA\u0026#39;)); // 4.位运算 // ~~ console.log(~~(true)); // 1 console.log(~~(false)); // 0 console.log(~~(null)); // 0 console.log(~~(undefined)); // 0 console.log(~~(NaN)); // 0 console.log(~~(\u0026#34;\u0026#34;)); // 0 console.log(~~(\u0026#34;123\u0026#34;)); // 123 console.log(~~(\u0026#34; 123\u0026#34;)); // 123 console.log(~~(\u0026#34;123.12\u0026#34;)); // 123 console.log(~~(\u0026#34;0xF\u0026#34;)); // 15 // \u0026lt;\u0026lt; console.log(true \u0026lt;\u0026lt; 0); // 1 console.log(false \u0026lt;\u0026lt; 0); // 0 console.log(null \u0026lt;\u0026lt; 0); // 0 console.log(undefined \u0026lt;\u0026lt; 0); // 0 console.log(NaN \u0026lt;\u0026lt; 0); // 0 console.log(\u0026#34;\u0026#34; \u0026lt;\u0026lt; 0); // 0 console.log(\u0026#34;123\u0026#34; \u0026lt;\u0026lt; 0); // 123 console.log(\u0026#34; 123\u0026#34; \u0026lt;\u0026lt; 0); // 123 console.log(\u0026#34;123.12\u0026#34; \u0026lt;\u0026lt; 0); // 123 console.log(\u0026#34;0xF\u0026#34; \u0026lt;\u0026lt; 0); // 15 // \u0026gt;\u0026gt; console.log(true \u0026gt;\u0026gt; 0); // 1 console.log(false \u0026gt;\u0026gt; 0); // 0 console.log(null \u0026gt;\u0026gt; 0); // 0 console.log(undefined \u0026gt;\u0026gt; 0); // 0 console.log(NaN \u0026gt;\u0026gt; 0); // 0 console.log(\u0026#34;\u0026#34; \u0026gt;\u0026gt; 0); // 0 console.log(\u0026#34;123\u0026#34; \u0026gt;\u0026gt; 0); // 123 console.log(\u0026#34; 123\u0026#34; \u0026gt;\u0026gt; 0); // 123 console.log(\u0026#34;123.12\u0026#34; \u0026gt;\u0026gt; 0); // 123 console.log(\u0026#34;0xF\u0026#34; \u0026gt;\u0026gt; 0); // 15 // 5.一元运算符 console.log(+(true)); // 1 console.log(+(false)); // 0 console.log(+(null)); // 0 console.log(+(undefined)); // NaN console.log(+(NaN)); // NaN console.log(+(\u0026#34;\u0026#34;)); // 0 console.log(+(\u0026#34;123\u0026#34;)); // 123 console.log(+(\u0026#34; 123\u0026#34;)); // 123 console.log(+(\u0026#34;123.12\u0026#34;)); // 123 console.log(+(\u0026#34;0xF\u0026#34;)); // 15 JS中的位运算\r#\rJavaScript的数字类型为双精度IEEE 754 64位浮点类型，但是在位运算中位运算符用于32位的数字上, 任何的数字操作都将转为32位, 运算结果再转化为Js数字类型。\n// \u0026amp; 按位与，可以用于判断奇偶性 console.log(7 \u0026amp; 1); console.log(8 \u0026amp; 1); // | 按位或，可以用来将值强制转换为32位整数类型 console.log(11.11 | 0); // 11 console.log(\u0026#34;11.11\u0026#34; | 0); // 11 console.log(\u0026#34;-11.11\u0026#34; | 0); // -11 console.log(1.23E2 | 0); // 123 console.log([] | 0); // 0 console.log(({}) | 0); // 0 // ^ 按位异或（相同为0，不同为1），可以用于交换数值 let a = 7; let b = 1; a ^= b; b ^= a; a ^= b; console.log(a); // 1 console.log(b); // 7 // 也可以借助数组 b = [a, a = b][0]; // 当然解构赋值更简单 [a, b] = [b, a]; // ~按位非 // ~~强制转换值为32位整数 console.log(~~(11.11)); // 11 console.log(~~(\u0026#34;11.11\u0026#34;)); // 11 console.log(~~(\u0026#34;-11.11\u0026#34;)); // -11 console.log(~~(1.23E2)); // 123 console.log(~~([])); // 0 console.log(~~({})); // 0 // \u0026lt;\u0026lt;左移 // \u0026gt;\u0026gt;有符号右移 // \u0026gt;\u0026gt;\u0026gt;无符号右移 JS创建对象的方式\r#\r// 字面量方式 var obj = { a: 1, b: {} } // Object构造函数 var obj = new Object(); obj.a = 1; obj.b = {}; // Object.create() var obj = Object.create(null); //创建一个没有原型链指向的对象 var obj = Object.create(Object.prototype); //等同于 new Object() // 工厂模式：构造创建对象的工厂，调用即产生对象，能够减少重复代码，减小代码冗余 function factory() { var o = new Object(); o.a = 1; o.b = {}; return o; } var obj = factory(); // 构造函数 function _object() { this.a = 1; this.b = {}; } var obj = new _object(); console.log(obj instanceof _object); // true // 原型模式 function _object1() {} _object1.prototype.a = 1; _object1.prototype.b = {}; var obj = new _object1(); console.log(obj); console.log(obj.a); console.log(obj.b); console.log(obj instanceof _object1); // true Object 对象的方法\r#\r复习一下遍历对象的方法： for in：用来遍历（对象自身+原型）可枚举属性 Object.keys()：遍历（对象自身）可枚举属性 Object.getOwnPropertyNames()：遍历（对象自身）可枚举属性+不可枚举属性 Object.getOwnPropertySymbols()：遍历（对象自身）Symbol属性 Reflect.ownKeys()：遍历（对象自身）可枚举属性+不可枚举属性+Symbol属性\n// Object.assign(target, ...sources) // 将一个或多个源对象的可枚举属性复制到目标对象上，返回目标对象的引用 // 拷贝方式是浅拷贝 console.log(\u0026#34;1.Object.assign()\u0026#34;); const s1 = {a: 1, c: { d: 2}}; const s2 = {b: 1}; const target = {}; Object.assign(target, s1, s2); // 地址拷贝，target的值随之改变，属于浅拷贝 s1.c.d = 3; // 值拷贝，target的值不会被影响 s1.a = 4; console.log(\u0026#39;修改后的s1\u0026#39;, s1); console.log(\u0026#39;修改后的target\u0026#39;, target); // Object.create(proto[, propertiesObject]) // 使用 proto 作为原型创建新的对象，可选参数是要添加到新对象上的不可枚举的属性描述符 console.log(\u0026#34;\\n2.Object.create()\u0026#34;); const proto = {a: 1, b: {c: 2}}; const newObj = Object.create(proto); console.log(\u0026#39;创建的新对象\u0026#39;, newObj); proto.a = 2; proto.b.c = 3; // 实现完整的浅拷贝 console.log(newObj.a); console.log(newObj.b.c); console.log(newObj.__proto__ === proto); // Object.is(val1, val2)判断两个值是否相同 /** * 两个值都是undefined * 两个值都是null * 两个值都是true或者都是false * 两个值是由相同个数的字符按照相同的顺序组成的字符串 * 两个值指向同一个对象 * 两个值都是数字并且，都是正零+0，都是负零-0，都是NaN * 都是除零和NaN外的其它同一个数字 */ console.log(\u0026#34;\\nObject.is()\u0026#34;); console.log(\u0026#39;Object.is(undefined, undefined)\u0026#39;, Object.is(undefined, undefined)); console.log(\u0026#39;Object.is(null, undefined)\u0026#39;, Object.is(null, undefined)); console.log(\u0026#39;Object.is(null, null)\u0026#39;, Object.is(null, null)); // Object.defineProperties(obj, props) // obj 对象 // props 定义或修改的属性描述符的对象 console.log(\u0026#34;\\n3.Object.defineProperties()\u0026#34;); const newObj1 = {}; Object.defineProperties(newObj1, { a: { value: 1, configurable: true, Writable: true, enumerable: true }, b: { value: 2, configurable: true, Writable: true, enumerable: true } }) console.log(newObj1); // 遍历可枚举属性 for (let i in newObj1) { //自身+原型上的可枚举属性 console.log(i); } // Object.defineProperty(obj, prop, descriptor) // obj 对象 // prop 定义或修改的属性描述符的对象 // descriptor 属性描述符对象 console.log(\u0026#34;\\n4.Object.defineProperty()\u0026#34;); // Object.entries(obj) // 返回一个给定对象obj 自身可枚举属性 的键值对数组，排列顺序与 for in 一致 console.log(\u0026#34;\\n5.Object.entries()\u0026#34;); // Object.values(obj) // 返回一个给定对象 自身的所有可枚举属性 值的数组 // Object.keys(obj) // 返回自身的可枚举属性的键 console.log(Object.keys(newObj1)); // Object.freeze(obj) // 冻结一个对象，不能添加、删除属性，不能修改属性配置和值，其原型也不能被修改 // 返回被冻结对象的引用 console.log(\u0026#34;\\n6.Object.freeze()\u0026#34;); const obj = {a: 1}; const freezeObj = Object.freeze(obj); console.log(\u0026#39;冻结前\u0026#39;, freezeObj); freezeObj.a = 2; console.log(\u0026#39;冻结后\u0026#39;, freezeObj); //打印{ a: 1 }，修改失败 // Object.isFrozen(obj) //判断一个对象是否被冻结 // Object.preventExtensions(obj) //让一个对象变的不可扩展，也就是永远不能再添加新的属性 // Object.isExtensible(obj) //判断一个对象是否是可扩展的 // Object.seal(obj) //封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置，当前属性的值只要原来是可写的就依旧可以改变 // Object.isSealed(obj) //判断一个对象是否被密封 // Object.fromEntries() // 把键值对列表(可迭代对象)转换为一个对象 console.log(\u0026#34;\\n7.Object.fromEntries()\u0026#34;); const arr = [[\u0026#39;a\u0026#39;, 1],[\u0026#39;b\u0026#39;, 2],[\u0026#39;c\u0026#39;, 3]] const newObj2 = Object.fromEntries(arr); console.log(\u0026#39;键值对列表转换结果\u0026#39;, newObj2); // Object.getOwnPropertyDescriptors() // 返回一个对象，由指定对象的所有自身属性的描述符组成，如果没有任何自身属性，则返回空对象 console.log(\u0026#34;\\n8.Object.getOwnPropertyDescriptors()\u0026#34;); const tar = {a: 1}; Object.defineProperty(tar, \u0026#39;key\u0026#39;, { // enumerable: false, value: 11, // writable: true }) const descriptor = Object.getOwnPropertyDescriptors(tar); console.log(descriptor); // Object.getOwnPropertyNames(obj) // 返回数组，由指定对象的自身属性的属性名组成（包括不可枚举属性），不包括symbol值作为名的属性，不包括原型上的属性 console.log(\u0026#34;\\n9.Object.getOwnPropertyNames(obj)\u0026#34;); // Object.getOwnPropertySymbols(obj) // 返回一个指定对象自身的所有Symbol属性的数组 console.log(\u0026#34;\\n10.Object.getOwnPropertySymbols(obj)\u0026#34;); // Object.setPrototypeOf(obj, prototype) // 设置一个指定的对象的原型即内部[[Prototype]]属性 // Object.getPrototypeOf(obj) // 返回指定对象的原型 console.log(\u0026#34;\\n11.Object.getPrototypeOf(obj)\u0026#34;); // 对象原型上的方法 // Object.prototype.hasOwnProperty(prop) 返回一个布尔值，判断对象自身属性是否具有指定的键 // Object.prototype.isPrototypeOf(object) 测试一个对象是否在另一个对象的原型链上 // Object.prototype.propertyIsEnumerable(prop) 返回一个布尔值，表示指定的属性是否可枚举 // Object.prototype.toLocaleString() 返回一个该对象的字符串表示 // Object.prototype.toString()方法返回一个表示该对象的字符串 // Object.prototype.valueOf()方法返回指定对象的原始值 Map与WeakMap、Set与WeakSet\r#\rMap与WeakMap：二者都用于保存键值对，其中Map中任意对象或原始值都可以作为键和值，WeakMap中键是弱引用的且必须为对象，值可以是任意对象或原始值。 Set与WeakSet：二者允许存储不重复的值，其中Set可以存储原始值或者对象引用，WeakSet只允许存储对象弱引用的唯一值。 弱引用：当弱引用对象没有其他引用时，垃圾回收机制就会释放该对象占用的内存，不需要手动删除引用。\nconsole.log(\u0026#34;===========\u0026gt;Map\u0026#34;); // 初始化 let m = new Map(); // 只读属性size，获取Map的键值对数量 console.log(m.size); // set(key, value) 设置键值对 m.set(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;); m.set(\u0026#34;key2\u0026#34;, \u0026#34;value2\u0026#34;); m.set(\u0026#34;key3\u0026#34;, \u0026#34;value3\u0026#34;); console.log(m.size); // has(key) // get(key) // delete(key) // clear() 清除map // Map是可迭代的 for (let item of m) { console.log(item); } for (let [key, value] of m.entries()) { console.log(key, value); } console.log(\u0026#34;===========\u0026gt;WeakMap\u0026#34;); let wm = new WeakMap(); let key = {name: \u0026#39;weakmap\u0026#39;} wm.set(key, \u0026#34;weakmap\u0026#34;); console.log(wm.has(key)); console.log(wm.get(key)); console.log(wm.delete(key)); console.log(\u0026#34;===========\u0026gt;Set\u0026#34;); let s = new Set(); s.add(1); s.add(2); console.log(s); console.log(s.has(1)); console.log(s.has(3)); // console.log(s.delete(2)); // console.log(s.delete(1)); s.forEach((n, b, s) =\u0026gt; { console.log(n, b, s); }) 源码（各自的属性与方法）\n/*! ***************************************************************************** Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. See the Apache Version 2.0 License for specific language governing permissions and limitations under the License. ***************************************************************************** */ /// \u0026lt;reference no-default-lib=\u0026#34;true\u0026#34;/\u0026gt; interface Map\u0026lt;K, V\u0026gt; { clear(): void; delete(key: K): boolean; forEach(callbackfn: (value: V, key: K, map: Map\u0026lt;K, V\u0026gt;) =\u0026gt; void, thisArg?: any): void; get(key: K): V | undefined; has(key: K): boolean; set(key: K, value: V): this; readonly size: number; } interface MapConstructor { new(): Map\u0026lt;any, any\u0026gt;; new\u0026lt;K, V\u0026gt;(entries?: readonly (readonly [K, V])[] | null): Map\u0026lt;K, V\u0026gt;; readonly prototype: Map\u0026lt;any, any\u0026gt;; } declare var Map: MapConstructor; interface ReadonlyMap\u0026lt;K, V\u0026gt; { forEach(callbackfn: (value: V, key: K, map: ReadonlyMap\u0026lt;K, V\u0026gt;) =\u0026gt; void, thisArg?: any): void; get(key: K): V | undefined; has(key: K): boolean; readonly size: number; } interface WeakMap\u0026lt;K extends object, V\u0026gt; { delete(key: K): boolean; get(key: K): V | undefined; has(key: K): boolean; set(key: K, value: V): this; } interface WeakMapConstructor { new \u0026lt;K extends object = object, V = any\u0026gt;(entries?: readonly [K, V][] | null): WeakMap\u0026lt;K, V\u0026gt;; readonly prototype: WeakMap\u0026lt;object, any\u0026gt;; } declare var WeakMap: WeakMapConstructor; interface Set\u0026lt;T\u0026gt; { add(value: T): this; clear(): void; delete(value: T): boolean; forEach(callbackfn: (value: T, value2: T, set: Set\u0026lt;T\u0026gt;) =\u0026gt; void, thisArg?: any): void; has(value: T): boolean; readonly size: number; } interface SetConstructor { new \u0026lt;T = any\u0026gt;(values?: readonly T[] | null): Set\u0026lt;T\u0026gt;; readonly prototype: Set\u0026lt;any\u0026gt;; } declare var Set: SetConstructor; interface ReadonlySet\u0026lt;T\u0026gt; { forEach(callbackfn: (value: T, value2: T, set: ReadonlySet\u0026lt;T\u0026gt;) =\u0026gt; void, thisArg?: any): void; has(value: T): boolean; readonly size: number; } interface WeakSet\u0026lt;T extends object\u0026gt; { add(value: T): this; delete(value: T): boolean; has(value: T): boolean; } interface WeakSetConstructor { new \u0026lt;T extends object = object\u0026gt;(values?: readonly T[] | null): WeakSet\u0026lt;T\u0026gt;; readonly prototype: WeakSet\u0026lt;object\u0026gt;; } declare var WeakSet: WeakSetConstructor; 函数柯里化\r#\r手动柯里化 // 柯里化的基本了解 // 通过闭包实现一个简单的柯里化函数 var add = function (x) { return function (y) { return x + y; } } console.log(add(1)(2)); console.log(add(1)(3)); console.log(add(1)(4)); // 箭头函数写法 var add2 = x =\u0026gt; y =\u0026gt; x+y; console.log(add2(3)(4)); // 柯里化案例一：打印日志 // 信息一：日志的时间 // 信息二：日志的类型 info/debug/feature // 信息三：日志的信息 // 1.没有柯里化的时候，每次都要传递三个参数 function logInfo(date, type, message) { console.log(`时间:${date} 类型:${type} 内容:${message}`); } logInfo(\u0026#39;2023-6-14\u0026#39;,\u0026#39;DEBUG\u0026#39;,\u0026#39;修复bug\u0026#39;) logInfo(\u0026#39;2023-6-14\u0026#39;,\u0026#39;DEBUG\u0026#39;,\u0026#39;又修复一个bug\u0026#39;) // 2.使用柯里化封装函数，只需传递每次不同的参数 var logInfo2 = date =\u0026gt; type =\u0026gt; message =\u0026gt; { console.log(`时间:${date} 类型:${type} 内容:${message}`); } var logToday = logInfo2(\u0026#39;2023-6-14\u0026#39;); var logDebug = logToday(\u0026#39;DEBUG\u0026#39;); var logFeature = logToday(\u0026#39;FEATURE\u0026#39;) logDebug(\u0026#39;修复bug1\u0026#39;); logDebug(\u0026#39;修复bug2\u0026#39;); logDebug(\u0026#39;修复bug3\u0026#39;); logFeature(\u0026#39;添加属性\u0026#39;); // 柯里化案例二：加法 var add = function (x) { // 保留参数x，返回接收剩余参数y的函数 return function (y) { return x + y; } } let adder1 = add(1); console.log(adder1(2)); console.log(adder1(3)); console.log(adder1(4)); 手写自动柯里化 function myCurrying(fn) { // args接收剩余参数 return function curryFn(...args) { // 判断当前参数数量是否大于等于fn的参数数量 // 大于等于：执行fn if (args.length \u0026gt;= fn.length) { // fn(...args); fn.apply(this, args); } // 否则：返回一个接收剩余参数的函数 else { return function (...newArgs) { // 在函数内部，拼接参数，递归 // return curryFn(...args, ...newArgs); return curryFn.apply(this, args.concat(newArgs)) } } } } function foo(x, y, z) { console.log(x + y + z); } var curryFoo = myCurrying(foo); var curry1 = curryFoo(10, 20); curry1(1); curryFoo(10)(20)(30); function logInfo(date, type, message) { console.log(`时间:${date} 类型:${type} 内容:${message}`); } var curryLogInfo = myCurrying(logInfo); var logToday = curryLogInfo(new Date()); logToday(\u0026#34;DEBUG\u0026#34;)(\u0026#39;修复一个错误\u0026#39;); JS中RegExp对象\r#\rRegExp.prototype.exec() 在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 RegExp.prototype.test() 执行一个检索，用来查看正则表达式与指定的字符串是否匹配。 RegExp.prototype[@@match] 和 String.prototype.match() 会返回一个数组，它包括整个匹配结果，和通过捕获组匹配到的结果，如果没有匹配到则返回 null。 // 判断邮箱的正则表达式 var re = /^\\w+@(\\w+\\.)+\\w+$/g; var str = \u0026#39;yuanyuanhong@nuaa.edu.cn\u0026#39;; // 为了判断是否匹配 console.log(re.test(str)); // true // 为了找出所有匹配的字符串 /* 两个方法返回相同的结果： 会返回一个数组，它包括整个匹配结果，和通过捕获组匹配到的结果（保存在group属性中）； 如果没有匹配到则返回 null。 \u0026#39;abc\u0026#39;.match(/a/); /a/[Symbol.match](\u0026#39;abc\u0026#39;); */ console.log(str.match(re)); // [ \u0026#39;yuanyuanhong@nuaa.edu.cn\u0026#39; ] console.log(re[Symbol.match](str)); // [ \u0026#39;yuanyuanhong@nuaa.edu.cn\u0026#39; ] // 当正则表达式设置 g 标志位时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配 console.log(re.exec(str)); /* [ \u0026#39;yuanyuanhong@nuaa.edu.cn\u0026#39;, 匹配的结果 \u0026#39;edu.\u0026#39;, 捕获组结果 index: 0, input: \u0026#39;yuanyuanhong@nuaa.edu.cn\u0026#39;, groups: undefined ] */ Function与Object\r#\rJS中所有对象都来自Object，所有对象从Object.prototype继承方法和属性，尽管它们可能被覆盖，例如其他构造函数在原型中实现自己的toString()方法。Object原型对象的更改将传播到所有对象，除非这些受到更改的属性和方法沿原型链被覆盖。\n// 定义三个对象 var a = function(){} // 构造函数对象 var b = new Array(1); // 数组对象 var c = new Number(1); // 数字对象 // 包装对象 // 检查原型链 console.log(a.__proto__.__proto__ === Object.prototype); // true console.log(b.__proto__.__proto__ === Object.prototype); // true console.log(c.__proto__.__proto__ === Object.prototype); // true // 拆分指向 console.log(a.__proto__ === Function.prototype); // true console.log(Function.prototype.__proto__ === Object.prototype); // true console.log(b.__proto__ === Array.prototype); // true console.log(Array.prototype.__proto__ === Object.prototype); // true console.log(c.__proto__ === Number.prototype); // true console.log(Number.prototype.__proto__ === Object.prototype); // true // 使用instanceof 实际也是检测原型链 // instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 console.log(a instanceof Object); // true console.log(b instanceof Object); // true console.log(c instanceof Object); // true JavaScript中的所有的构造函数都继承自Function，包括Object构造函数，Function构造函数也继承于自己，当然Function也是继承于Object.prototype，可以说是先有的Object.prototype， Object.prototype构造出Function.prototype，然后Function.prototype构造出Object和Function。\n// 构造函数对象 var a = function(){} // 构造函数对象 // 检查原型链 console.log(a.__proto__ === Function.prototype); // true console.log(Object.__proto__ === Function.prototype); // true console.log(Function.__proto__ === Function.prototype); // true console.log(Function.prototype.__proto__ === Object.prototype); // true // 使用instanceof console.log(a instanceof Function); // true console.log(Object instanceof Function); // true console.log(Function instanceof Function); // true 总结：\n一切对象都继承于Object，都是从Object.prototype继承方法和属性。 一切构造函数包括Object与Function，都继承于Function，最终继承于Object Promise.race()改进，能够处理非promise\r#\r思路：每个promise用Promise.resolve()包裹，这样就可以捕获非promise的处理结果了。\nPromise.race = function (promises) { if (!Array.isArray(promises)) { return Promise.reject(\u0026#39;参数出错\u0026#39;); } return new Promise((resolve, reject) =\u0026gt; { for (let i = 0; i \u0026lt; promises.length; i++) { Promise.resolve(promises[i]) .then(res =\u0026gt; { resolve(res); }) .catch(err =\u0026gt; { reject(err); }) } }) } var promise1 = new Promise((resolve) =\u0026gt; { setTimeout(resolve, 1000, \u0026#39;promise1 成功\u0026#39;) }) var promise3 = new Promise((resolve, reject) =\u0026gt; { setTimeout(reject, 100, \u0026#39;promise3 失败\u0026#39;) }) // var promise4 = new Promise((resolve, reject) =\u0026gt; { reject(\u0026#39;promise4 失败\u0026#39;) }).catch(err =\u0026gt; console.log(err)) // 打印：promise3 失败 Promise.race([promise1, promise3]) .then(res =\u0026gt; console.log(res)) .catch(err =\u0026gt; console.log(err)) // 打印：成功的更快 Promise.race([Promise.resolve(\u0026#39;成功的更快\u0026#39;), promise3]) .then(res =\u0026gt; console.log(res)) .catch(err =\u0026gt; console.log(err)) // 打印：参数出错 Promise.race(1) .then(res =\u0026gt; console.log(res)) .catch(err =\u0026gt; console.log(err)) var p1 = 1; var p2 = new Error(\u0026#39;出错\u0026#39;) Promise.race([promise1, p2]) .then(res =\u0026gt; console.log(res)) .catch(err =\u0026gt; console.log(err)) 手写vue-router\r#\rVueRouter是一个构造函数，参数是路由配置{routes, mode}。根据参数获取路由配置和路由模式，然后根据路由模式监听首次加载和路由改变事件，获取到最新的路由值。 Vue.use()的作用：用来注册插件（限制重复注册），执行括号里面的方法（有install就执行install，没有就执行函数本身）。其中install方法的第一个参数是Vue的构造函数。 默认export default router为什么要暴露到main.js中，有什么作用？——将router放到根实例的$options中，为了让所有组件都可以拿到这个属性。（可以加到vue的原型链上） vue-router中的两个全局组件，router-link渲染成a标签，router-view通过获得当前url对应的组件并渲染 let Vue class VueRouter { constructor (options) { // console.log(options.routes); // 路由模式 this.mode = options.mode || \u0026#39;hash\u0026#39;; // 路由配置 this.routes = options.routes; // 用于保存最新的路由，使用了vue3的响应式 let initData = window.location.hash.slice(1) || \u0026#39;/\u0026#39;; Vue.util.defineReactive(this, \u0026#39;current\u0026#39;,initData) // this.current = \u0026#39;/\u0026#39;; this.init(); //监听路由 } init() { if (this.mode === \u0026#39;hash\u0026#39;) { // 首次加载 window.addEventListener(\u0026#39;load\u0026#39;, () =\u0026gt; { this.current = window.location.hash.slice(1); console.log(this.current); }) // 路由更新 window.addEventListener(\u0026#39;hashchange\u0026#39;, () =\u0026gt; { this.current = window.location.hash.slice(1) console.log(this.current); }) } } } VueRouter.install = function (_vue) { Vue = _vue; // 给vue添加全局组件和方法 Vue.mixin({ // 混入，比组件自身的声明周期调用更早 beforeCreate() { if (this.$options.router) { // 在根组件中拿到router，加到Vue实例上 Vue.prototype.$router = this.$options.router } } }) Vue.component(\u0026#39;router-link\u0026#39;,{ props: { to : { type: String, require: true } }, render(h) { return h(\u0026#39;a\u0026#39;,{ attrs: { href : \u0026#39;#\u0026#39; + this.to } }, // 获取组件内容 this.$slots.default) } }) Vue.component(\u0026#39;router-view\u0026#39;, { render(h) { console.log(this.$router); // $router已经被放到Vue原型上，所以在router-view组件中可以拿到 let current = this.$router.current; let routes = this.$router.routes; // 根据current获取对应组件 let router = routes.find(item =\u0026gt; item.path === current) console.log(router); return h(router.component) } }) } export default VueRouter JS遍历对象\r#\rconst obj = { name: \u0026#39;lcj\u0026#39;, age: 18, [Symbol()] : \u0026#39;symbol\u0026#39; } // 原型上的可枚举属性 Object.prototype.c = \u0026#39;我是原型上的属性\u0026#39; // 自身的不可枚举属性 Object.defineProperty(obj, \u0026#39;unenum\u0026#39;, { enumerable : false, value : \u0026#39;value\u0026#39; }) // for ... in ... 遍历对象（包括原型上的）所有可枚举属性，不按属性的顺序 console.log(\u0026#39;for in 遍历对象（包括原型上的）所有可枚举属性的值，不包括symbol:\u0026#39;); for (let i in obj) { console.log(obj[i]); } // Object.keys() 遍历对象自身所有可枚举属性，和 for in 遍历的顺序一样 console.log(\u0026#39;\\nObject.keys(obj)遍历对象自身所有可枚举属性的属性名，不包括symbol:\u0026#39;); var keys = Object.keys(obj); console.log(keys); // Object.getOwnPropertyNames() 遍历 console.log(\u0026#39;\\nObject.getOwnPropertyNames(obj)遍历对象自身所有属性的属性名（枚举+不可枚举），不包括symbol:\u0026#39;); var getOwnPropertyNames = Object.getOwnPropertyNames(obj); console.log(getOwnPropertyNames); // Object.getOwnPropertySymbols() 遍历 console.log(\u0026#39;\\nObject.getOwnPropertySymbols(obj)遍历对象自身所有 Symbol 属性的属性名:\u0026#39;); var getOwnPropertySymbols = Object.getOwnPropertySymbols(obj); console.log(getOwnPropertySymbols); // 获取对象自身属性，枚举 + 不可枚举 + Symbol： console.log(\u0026#39;\\nReflect.ownKeys(obj)遍历对象自身属性名，枚举 + 不可枚举 + Symbol\u0026#39;); var re = Reflect.ownKeys(obj); console.log(re); JS将多维数组转化为一维数组\r#\rvar arr = [1, [2, 3, [4, 5]]]; // 1.先转为字符串，再根据逗号分割 var res1 = arr.toString().split(\u0026#39;,\u0026#39;); var res2 = arr.join().split(\u0026#39;,\u0026#39;); console.log(res1); console.log(res2); // 2.递归 var res3 = []; getArr(arr); console.log(res3); function getArr(arr) { for (let a of arr) { if (Array.isArray(a)) { getArr(a); } else { res3.push(a); } } } // 3.concat 这种方法只能减少一个维度 var res4 = [].concat.apply(arr); console.log(res4); Promise方法学习\r#\rvar promise1 = new Promise((resolve) =\u0026gt; { setTimeout(resolve, 1000, \u0026#39;promise1 成功\u0026#39;)}) var promise2 = new Promise((resolve) =\u0026gt; { setTimeout(resolve, 100, \u0026#39;promise2 成功\u0026#39;) }) var promise3 = new Promise((resolve, reject) =\u0026gt; { setTimeout(reject, 100, \u0026#39;promise3 失败\u0026#39;) }) var promise4 = new Promise((resolve, reject) =\u0026gt; {reject(\u0026#39;promise4 失败\u0026#39;)}) /** * Promise.allSettled() * 接收promise数组 * 返回结果数组 * .then()接收结果的数组作为参数 */ // 打印： // [ // { status: \u0026#39;fulfilled\u0026#39;, value: \u0026#39;promise1 成功\u0026#39; }, // { status: \u0026#39;fulfilled\u0026#39;, value: \u0026#39;promise2 成功\u0026#39; }, // { status: \u0026#39;rejected\u0026#39;, reason: \u0026#39;promise3 失败\u0026#39; } // ] Promise.allSettled([promise1, promise2, promise3]).then(res =\u0026gt; console.log(res)) /** * Promise.all() * 接收Promise数组 * 若所有Promise成功，返回结果数组 * 若有一个Promise失败，立即返回失败结果： */ // 打印：\u0026#39;promise4 失败\u0026#39;（第一个抛出的失败信息） Promise.all([promise1, promise2, promise3, promise4]) .then(res =\u0026gt; console.log(res)) .catch(err =\u0026gt; console.log(err)) /** * Promise.any() * 当我们只需要一个 promise 兑现，而不关心是哪一个兑现时此方法很有用的。 * 接收Promise数组 * 若任意一个Promise成功，就返回第一个成功的结果： * 若都不成功，返回AggregateError，所有错误的结果： */ // 打印：promise2 成功（第一个成功的是promise2） Promise.any([promise1, promise2, promise3]).then(res =\u0026gt; console.log(res)) // 打印：[AggregateError: All promises were rejected] { // [errors]: [\u0026#39;promise3 失败\u0026#39;, \u0026#39;promise3 失败\u0026#39;] // } Promise.any([promise3, promise3]).catch(err =\u0026gt; console.log(err)) /** * Promise.race() * 给定的迭代中的一个 promise 解决或拒绝，就采用第一个 promise 的值作为它的值： */ // 打印：promise3 失败 Promise.race([promise1, promise3]).catch(err =\u0026gt; console.log(err)) // 打印：成功的更快 Promise.race([Promise.resolve(\u0026#39;成功的更快\u0026#39;), promise3]).then(res =\u0026gt; console.log(res)) 获取url参数\r#\rfunction getUrlParam(sUrl, sKey) { let parms = sUrl.split(\u0026#39;?\u0026#39;)[1].split(\u0026#39;#\u0026#39;)[0].split(\u0026#39;\u0026amp;\u0026#39;); var res = {}; for (let p of parms) { p = p.split(\u0026#39;=\u0026#39;); // console.log(p); if (res[p[0]] === undefined) res[p[0]] = []; res[p[0]].push(p[1]); } if (sKey !== \u0026#39;\u0026#39;) { return res[sKey] || \u0026#39;\u0026#39;; } return res; } var params = getUrlParam(\u0026#39;https://details/120288882?key=1\u0026amp;key=2\u0026amp;text=3\u0026amp;text=2\u0026amp;num=3#\u0026#39;, \u0026#39;num\u0026#39;); console.log(params); #\rasync/awit\r#\rasync函数 返回一个 Promise 对象，可以用 then()处理成功回调、catch()捕获异常。函数没有返回值的话默认会进入fullfilled状态：{ PromiseState: fullfilled, PromiseResult: undefined}。 function promise() { return new Promise((resolve, reject) =\u0026gt; { var rand = Math.random() * 2; setTimeout(() =\u0026gt; { resolve(`solve ${rand}`); }, 1000); }) } async function asyncPromise() { var result = await promise(); console.log(result); } var p = asyncPromise(); console.log(p); // p VM54:17 Promise {\u0026lt;pending\u0026gt;} [[Prototype]]: Promise [[PromiseState]]: \u0026#34;fulfilled\u0026#34; [[PromiseResult]]: undefined // result VM54:13 solve 0.7067351783995486 generator函数\r#\rfunction *f(x) { console.log(\u0026#39;第一次next()运行\u0026#39;); yield x + 10; console.log(\u0026#39;第二次next()运行\u0026#39;); yield x + 20; console.log(\u0026#39;第三次next()运行\u0026#39;); return x + 30; } var it = f(1); console.log(it); console.log(it.next()); console.log(it.next()); console.log(it.next()); console.log(it.next()); function* gen1(arg) { console.log(\u0026#39;打印参数：\u0026#39;, arg); let one = yield 111; //one被赋值为BBB console.log(\u0026#39;one=\u0026#39;, one); let two = yield 222; //two被赋值为CCC console.log(\u0026#39;two=\u0026#39;, two); let three = yield 333; //three被赋值为DDD console.log(\u0026#39;three=\u0026#39;, three); } let it1 = gen1(\u0026#39;AAA\u0026#39;); console.log(1, it1.next()); console.log(2, it1.next(\u0026#39;BBB\u0026#39;)); console.log(3, it1.next(\u0026#39;CCC\u0026#39;)); console.log(4, it1.next(\u0026#39;DDD\u0026#39;)); function* f1(x) { // 左边的y等待传参 var y = yield x + 10; console.log(y); let z = yield x + y; console.log(x, y, z); return x + 30; } var g = f1(1); console.log(g); // f {\u0026lt;suspended\u0026gt;} console.log(g.next()); // {value: 11, done: false} console.log(g.next(50)); // {value: 51, done: false} // y被赋值为50 console.log(g.next()); // {value: 31, done: true} // x,y 1,50 console.log(g.next()); // {value: undefined, done: true} new运算符\r#\r/** * new关键字 * * 语法：new constructor[([arguments])]，其中 * constructor 指定 对象实例类型 的 类或函数 * arguments 用于被constructor调用的参数列表 * * * new关键字的操作： * 1. 创建一个空对象 {} * 2. 为 步骤1 创建的对象添加属性 __proto__，指向构造函数的原型对象（这个对象就成为了构造函数的实例） * 3. 将 步骤1 创建的对象作为 this 上下文（使构造函数的this指针指向 步骤1 创建的对象，并传递参数） * 4. 若构造函数有返回对象，就返回该对象；否则返回 步骤1 创建的对象 * * * 代码实现： */ function _new(constructor, ...args) { const obj = {}; obj.__proto__ = constructor.prototype; let result = constructor.apply(obj, args); return typeof result === \u0026#34;object\u0026#34; ? result : obj; } function person(name, age) { this.name = name; this.age = age; } var lcj = _new(person,\u0026#39;lcj\u0026#39;, 18); console.log(lcj); JS遍历数组的方法\r#\rfor、forEach、map、for in、for of、every、some、find、findIndex、filter\n// for var arr1 = [1, 2, 3, 4, 5] for (let i=0, len = arr1.length; i \u0026lt; len; i++) { console.log(arr1[i]); } // for in 遍历数组效率非常低，主要是用来循环遍历对象的属性 // 数组遍历时需注意，数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同 // 不能保证for ... in将以任何特定的顺序返回索引 // for ... in循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些 // 因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素 // 因此当迭代访问顺序很重要的数组时，最好用整数索引去进行for循环 var arr1 = [1, 2, 3, 4, 5] for (let i in arr1) { console.log(arr1[i]); } var obj = {name: \u0026#39;lcj\u0026#39;} for (let i in obj) { console.log(obj[i]); } // for of // 在可迭代对象包括Array，Map，Set，String，TypedArray，arguments对象等等上 // 创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 var arr1 = [1, 2, 3, 4, 5] for (let item of arr1) { console.log(item); } // forEach 使用频率较高，但是性能不如普通for循环 // 可以添加第二个参数，指定回调函数的this，若回调函数是箭头函数则无效 var arr1 = [1, 2, 3, 4, 5] arr1.forEach(function (currentValue, currentIndex, array) { console.log(\u0026#39;当前值：\u0026#39;,currentValue); console.log(\u0026#39;当前下标：\u0026#39;,currentIndex); console.log(\u0026#39;遍历数组：\u0026#39;,array) console.log(\u0026#39;没有返回值\u0026#39;); } ) // map 回调函数return的结果组成了新数组的每一个元素，原数组被映射成对应新数组 // 可以添加第二个参数，指定回调函数的this，若回调函数是箭头函数则无效 var arr1 = [1, 2, 3, 4, 5] var arr2 = arr1.map(function (currentValue, currentIndex, array) { console.log(\u0026#39;当前值：\u0026#39;, currentValue); console.log(\u0026#39;当前下标：\u0026#39;, currentIndex); console.log(\u0026#39;遍历数组：\u0026#39;, array) console.log(\u0026#39;有返回值\u0026#39;); return currentValue + 1; } ) console.log(arr2); console.log(arr1); var arr = [1, 2, 3, 4, 5]; // arr.every(callback(currentValue [, index [, array]])[, thisArg]) // every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值 console.log(arr.every((currentValue) =\u0026gt; { return currentValue \u0026gt; 1; })) // false console.log(arr.every((currentValue) =\u0026gt; { return currentValue \u0026gt; 0; })) // true // arr.some(callback(element[, index[, array]])[, thisArg]) // some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值 console.log(arr.some((currentValue) =\u0026gt; { return currentValue \u0026gt; 1; })) // true console.log(arr.some((currentValue) =\u0026gt; { return currentValue \u0026gt; 6; })) // false // arr.find(callback(element[, index[, array]])[, thisArg]) // find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined console.log(arr.find((currentValue) =\u0026gt; { return currentValue \u0026gt; 2; })) // 3 console.log(arr.find((currentValue) =\u0026gt; { return currentValue \u0026gt; 6; })) // undefined // arr.findIndex(callback(element[, index[, array]])[, thisArg]) // findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引，否则返回-1 console.log(arr.findIndex((currentValue) =\u0026gt; { return currentValue \u0026gt; 2; })) // 2 console.log(arr.findIndex((currentValue) =\u0026gt; { return currentValue \u0026gt; 6; })) // -1 // arr.filter(callback(element[, index[, array]])[, thisArg]) // filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素 console.log(arr.filter((currentValue) =\u0026gt; { return currentValue \u0026gt; 2; })) // [3, 4, 5] apply、call、bind\r#\rfunction f(...args) { console.log(this.name, args); } const obj = { name: \u0026#39;lcj\u0026#39; } Function.prototype.myApply2 = function (obj) { obj.fn = this; let args = [...arguments][1] || []; let result = obj.fn(...args); delete obj.fn return result } f.myApply2(obj, [1, 2]); f.myApply2(obj, [1]); f.myApply2(obj); Function.prototype.myCall = function (obj) { obj.fn = this; let args = [...arguments].slice(1); let result = obj.fn(...args); delete obj.fn; return result; } f.myCall(obj, 1, 2); f.myCall(obj, 1); f.myCall(obj); Function.prototype.myBind = function (obj) { let fn = this; let args1 = [...arguments].slice(1); return function(...args2) { args1 = args1.concat(args2); return fn.call(obj,...args1); } } f.myBind(obj, 1, 3)(2, 4); f.myBind(obj)(); 手动实现Ajax\r#\rvar XMLHttpRequest = require(\u0026#39;xmlhttprequest\u0026#39;).XMLHttpRequest; function ajax(url, method = \u0026#34;GET\u0026#34;, data = null, async = true) { // 声明XMLHttpRequest //在IE5和IE6中需要使用ActiveX对象 // var XHR = XMLHttpRequest; // 创建XMLHttqRequest var XHR = new XMLHttpRequest() // 设置请求状态改变时执行的函数 XHR.onreadystatechange = function () { if (XHR.readyState === 4) console.log(`响应状态:${XHR.status}`, \u0026#34;FINISH\u0026#34;) //XHR.responseText为响应体 } // 初始化请求参数 XHR.open(method, url, async) // 发起请求 XHR.send(data) } ajax(\u0026#34;https://www.baidu.com\u0026#34;); ajax(\u0026#34;https://www.baidu.com\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;A=1\u0026amp;B=2\u0026#34;); // 自己写一个 var myXHR = new XMLHttpRequest(); myXHR.onreadystatechange = function () { if (myXHR.readyState == 4) { console.log(`请求成功，响应状态：${myXHR.status}`); } } myXHR.open(\u0026#39;GET\u0026#39;, \u0026#39;https://www.baidu.com\u0026#39;, true); myXHR.send(null) arguments对象转数组\r#\rfunction func1(a, b, c) { console.log(Array.prototype.slice.call(arguments)); console.log([...arguments]); console.log(Array.from(arguments)); } func1(1, 2, 3); 防抖和节流\r#\r// 非立即防抖： // 当持续触发事件的时候，事件处理函数是完全不执行的， // 等最后一次触发结束的一段时间之后，再去执行。 // 实现思路：每次触发事件时都取消之前的延时调用方法并重设定时器。 function debounce1(func, delay) { var timer = null; return function (...args) { clearTimeout(timer); timer = setTimeout(() =\u0026gt; { func(...args) }, delay); } } // 立即防抖： // 当持续触发事件的时候，事件处理函数会立即执行， // 然后不再执行事件处理函数，直至最后一次事件触发之后的一段时间后才允许再次执行事件处理函数。 // 实现思路：判断是否存在定时器，没有则执行事件处理函数， // 然后无论是否已经存在定时器都需要重设定时器。 function debounce2(func, delay) { var timer = null; return function (...args) { if (!timer) func(...args); clearTimeout(timer); timer = setTimeout(() =\u0026gt; { timer = null; }, delay); } } // 节流：判断是否存在定时器，没有则执行事件处理函数并重设定时器。 function throttle(func, delay, ...args) { var timer = null; return () =\u0026gt; { if (!timer) { func(...args); timer = setTimeout(() =\u0026gt; { timer = null; }, delay); } } } 深拷贝\r#\r原生方法实现深拷贝：主要是使用JSON.parse()与JSON.stringify()，首先将对象序列化为JSON字符串，再将JSON字符串反序列化为对象。\n// 原生方法实现深拷贝，JSON.parse 和 JSON.stringify function deepCopy(origin) { return JSON.parse(JSON.stringify(origin)); } const a = { name : \u0026#39;lcj\u0026#39; } var aCopy = deepCopy(a); a.name = \u0026#39;hyy\u0026#39;; console.log(a); console.log(aCopy); lodash.cloneDeep 库函数实现深拷贝\nvar _ = require(\u0026#39;lodash\u0026#39;); const b = { name: \u0026#39;lcj\u0026#39; } var bCopy = _.cloneDeep(b); b.name = \u0026#39;hyy\u0026#39;; console.log(b); console.log(bCopy); 浅拷贝\r#\r// 浅拷贝 // 手写方法：只复制第一层的浅拷贝 console.log(\u0026#39;手写方法实现浅拷贝\u0026#39;) function simpleCopy(obj1) { var obj2 = Array.isArray(obj1) ? [] : {}; for (let i in obj1) { obj2[i] = obj1[i]; } return obj2; } var obj1 = { a: 1, b: 2, c: { d: 3 } } var obj2 = simpleCopy(obj1); // 基本数据类型，拷贝值，修改拷贝数据不会影响原始数据 obj2.a = 3; obj2.b = 7; // 引用数据类型，拷贝内存地址，修改拷贝数据会影响原始数据 obj2.c.d = 4; // 打印结果 console.log(\u0026#39;obj1.a\u0026#39;,obj1.a); // 1 console.log(\u0026#39;obj2.a\u0026#39;,obj2.a); // 3 console.log(\u0026#39;obj1.b\u0026#39;,obj1.b); // 2 console.log(\u0026#39;obj2.b\u0026#39;,obj2.b); // 7 console.log(\u0026#39;obj1.c.d\u0026#39;,obj1.c.d); // 4 console.log(\u0026#39;obj2.c.d\u0026#39;,obj2.c.d); // 4 // 其他实现浅拷贝的方法 let a = [1] let arr = [4, 5, [6, 7]] let copy1 = arr.slice(0) let copy2 = a.concat(arr) console.log(\u0026#39;\\n数组方法实现浅拷贝\u0026#39;) // 基本数据类型，不会影响原始数据 arr[0] = \u0026#39;0\u0026#39; copy1[0] = \u0026#39;1\u0026#39; copy2[0] = \u0026#39;2\u0026#39; // 引用数据类型，拷贝内存地址，修改拷贝数据会影响原始数据 copy1[2][1] = 2 console.log(\u0026#39;arr\u0026#39;,arr) console.log(\u0026#39;copy1\u0026#39;,copy1) console.log(\u0026#39;copy2\u0026#39;,copy2) copy2[3][0] = 1 console.log(\u0026#39;arr\u0026#39;, arr) console.log(\u0026#39;copy1\u0026#39;, copy1) console.log(\u0026#39;copy2\u0026#39;, copy2) console.log(\u0026#39;\\nObject.assign实现浅拷贝\u0026#39;) // Object.assign(target, source_1, ···) let target = { a : 1 } let ob1 = { b : 2 } let ob2 = { c : { d : 3 } } Object.assign(target, ob1, ob2); console.log(\u0026#39;assign后的target：\u0026#39;,target) // target.b不会变 ob1.b = 4 console.log(\u0026#39;修改b后的target：\u0026#39;, target) // target.c.d会变 ob2.c.d = 5 console.log(\u0026#39;修改c.d后的target：\u0026#39;, target) console.log(\u0026#39;\\n拓展运算符实现浅拷贝\u0026#39;) let op1 = { a : 1, b : { c : 1 } } let op2 = {...op1} // op2.a没有被改变 op1.a = 2; console.log(\u0026#39;op1\u0026#39;, op1); console.log(\u0026#39;op2\u0026#39;, op2); // op2.b.c被改变 op1.b.c = 2; console.log(\u0026#39;op1\u0026#39;, op1); console.log(\u0026#39;op2\u0026#39;, op2); 数组排序\r#\r// 1.使用数组的方法sort() // 默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的 let values = [3, 2, 6, 11, 1, 19] // 从小到大(更简单的写法) values.sort((a, b) =\u0026gt; a - b) console.log(\u0026#39;sort从小到大：\u0026#39;, values) // 从大到小 values.sort((a, b) =\u0026gt; a \u0026lt;= b ? 1 : -1) console.log(\u0026#39;sort从大到小：\u0026#39;, values) // 2.冒泡排序 function bubbleSort(arr) { for (let i = 0; i \u0026lt; arr.length-1; i++) { // 优化：flag判断当前排序是否已经排好序，如果已经排好，就立即结束循环 let flag = true; for (let j = 0; j \u0026lt; arr.length-1-i ; j++) { if (arr[j] \u0026gt; arr[j+1]) { flag = false; let tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; } } if (flag) { break; } } return arr; } values = [3, 2, 6, 11, 1, 19] console.log(\u0026#39;冒泡排序：\u0026#39;, bubbleSort(values)) // 3.选择排序 function selectSort(arr) { for (let i = 0; i \u0026lt; arr.length-1; i++) { let index = i; for (let j = i+1; j \u0026lt; arr.length; j++) { if (arr[j] \u0026lt; arr[index]){ index = j; } } if (index != i) { let tmp = arr[index]; arr[index] = arr[i]; arr[i] = tmp; } } return arr; } values = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221] console.log(\u0026#39;选择排序：\u0026#39;, selectSort(values)) // 4.插入排序 function insertSort(arr) { for (let i = 1; i \u0026lt; arr.length; i++) { let j = i-1; let cur = arr[i]; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; cur) { arr[j+1] = arr[j]; j--; } arr[j+1] = cur; } return arr; } values = [3, 2, 6, 11, 1, 19] console.log(\u0026#39;插入排序：\u0026#39;, insertSort(values)) // 5.快速排序 function quickSort(arr) { if (arr.length \u0026lt; 2) { return arr; } // 取出数组的第一项 let middle = arr[0]; // 两个数组分别用来存 小于等于中间项 和 大于中间项 的值 let left = []; let right = []; for (let i = 1; i \u0026lt; arr.length; i++) { if (arr[i] \u0026lt;= middle) { left.push(arr[i]); } else if (arr[i] \u0026gt; middle) { right.push(arr[i]); } } // 递归并拼接数组 return quickSort(left).concat(middle, quickSort(right)) } values = [3, 2, 3, 6, 19, 11, 1, 19] console.log(\u0026#39;快速排序：\u0026#39;, quickSort(values)) values = [3, 2, 6, 11, 1, 19] console.log(\u0026#39;快速排序：\u0026#39;, quickSort(values)) values = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221] console.log(\u0026#39;快速排序：\u0026#39;, quickSort(values)) // 6.归并排序 // 7.堆排序 // 堆排序 function heapSort(arr) { let len = arr.length; // 从第一个非叶子节点往前，调整大顶堆 for (let i = Math.floor(len / 2); i \u0026gt;= 0; i--) { heapAdjust(arr, i, len); } for (let i = len-1; i \u0026gt;= 0; i--) { // 交换堆顶和对尾 let tmp = arr[i]; arr[i] = arr[0]; arr[0] = tmp; // 对堆顶进行调整 heapAdjust(arr, 0, i); } return arr function heapAdjust(arr, parent, end) { // arr 数组 // parent 当前调整的根节点 // end 堆的长度 // 左孩子下标 let child = parent * 2 + 1; // 当前根节点 let tmp = arr[parent]; while (child \u0026lt; end) { // 找两个孩子中的最大值 if (child + 1 \u0026lt; end \u0026amp;\u0026amp; arr[child + 1] \u0026gt; arr[child]) { child = child + 1; } // 比较父节点和孩子节点的大小，如果父节点大，结束循环 if (tmp \u0026gt;= arr[child]) { break; } // 如果孩子节点大，把更大的值放上来，然后继续向下寻找放tmp的位置 arr[parent] = arr[child]; parent = child; child = parent * 2 + 1; } // 没有孩子节点了，或者孩子节点都小，找到放tmp的位置 arr[parent] = tmp; } } values = [3, 2, 3, 6, 19, 11, 1, 19] console.log(\u0026#39;堆排序：\u0026#39;, heapSort(values)) values = [3, 2, 6, 11, 1, 19] console.log(\u0026#39;堆排序：\u0026#39;, heapSort(values)) values = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221] console.log(\u0026#39;堆排序：\u0026#39;, heapSort(values)) // 归并排序 function mergeSort(arr) { if (arr.length \u0026lt;= 1) { return arr; } // 中间下标 let mid = Math.floor(arr.length / 2); // 左边排序 let arr1 = mergeSort(arr.slice(0, mid)); // 右边排序 let arr2 = mergeSort(arr.slice(mid)); // 合并有序数组 return mergeArray(arr1, arr2); // 合并两个已经排序的数组 function mergeArray(arr1, arr2) { let res = []; let ll = 0,lr = 0; while (ll \u0026lt; arr1.length \u0026amp;\u0026amp; lr \u0026lt; arr2.length) { if (arr1[ll] \u0026lt;= arr2[lr]) { res.push(arr1[ll]); ll++; } else { res.push(arr2[lr]); lr++; } } while (ll \u0026lt; arr1.length) { res.push(arr1[ll]); ll++; } while (lr \u0026lt; arr2.length) { res.push(arr2[lr]); lr++; } return res; } } values = [3, 2, 3, 6, 19, 11, 1, 19] console.log(\u0026#39;归并排序：\u0026#39;, mergeSort(values)) values = [3, 2, 6, 11, 1, 19] console.log(\u0026#39;归并排序：\u0026#39;, mergeSort(values)) values = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221] console.log(\u0026#39;归并排序：\u0026#39;, mergeSort(values)) instanceOf原理\r#\rlet person = function () { } let no = new person() console.log(no instanceof person) function new_instance_of(leftValue, rightVaule) { let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值 leftValue = leftValue.__proto__; // 取左表达式的__proto__值 while (leftValue) { if (leftVaule === rightProto) { return true; } leftValue = leftValue.__proto__ } return false; } console.log(new_instance_of(no, person)) vue数组响应式方法\r#\rbtnClick(){ // 1.push()方法：可以同时添加多个元素，可以传入多个值 // this.letters.push(\u0026#39;aaa\u0026#39;) // 2.pop()：删除数组中的最后一个元素 // this.letters.pop() // 3.shift()：删除数组中的第一个元素 // this.letters.shift() // 4.unshift()：在数组最前面添加元素(可以添加多个) // this.letters.unshift(\u0026#39;aaa\u0026#39;) // 5.splice() 删除元素/插入元素/替换元素 // 删除元素：第二个参数传入要删除几个元素（如果没有传，就删除后面所有的元素） // this.letters.splice(2,2) // 替换元素：第二个参数表示要替换几个元素，后面是用于替换前面的元素 // this.letters.splice(1,3,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;l\u0026#39;) // 插入元素：第二个参数传入0，并且后面跟上要插入的元素 // this.letters.splice(2,0,\u0026#39;k\u0026#39;) // 6.sort()排序 // this.letters.sort() // 7.reverse()翻转 // this.letters.reverse() //注意：通过索引值修改数组中的元素，不是响应式的 // this.letters[0] = \u0026#39;bbb\u0026#39; } CSS画三角形\r#\r\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 使用 border */ .box:first-child { width: 0; height: 0; border: 100px solid transparent; /* border-right: 100px solid gray; */ border-bottom: 100px solid gray; } /* 使用线性渐变 linear-gradient */ .box:nth-child(2) { width: 100px; height: 100px; background: linear-gradient(45deg, deeppink, deeppink 50%, transparent 50%,transparent 100%); } /* 使用 transform: rotate 配合 overflow: hidden */ .box:nth-child(3) { width: 141px; height: 100px; position: relative; overflow: hidden; } .box:nth-child(3)::before { content: \u0026#34;\u0026#34;; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: deeppink; /* 旋转的点是左上角 */ transform-origin: left top; transform: rotate(45deg); } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 盒子水平居中\r#\r.father1 { /* flex布局 */ /* display: flex; justify-content: center; align-items: center; */ /* grid布局 */ display: grid; justify-content: center; align-content: center; margin-bottom: 10px; width: 300px; height: 300px; background-color: pink; } .son1 { width: 100px; height: 100px; background-color: #fff; } .father2 { margin-bottom: 10px; width: 300px; height: 300px; background-color: pink; } .son2 { /* 相当于 position: relative; top: calc(50% - 高度一半); left: calc(50% - 宽度一半);*/ /* 或者 */ position: relative; top: 50%; margin:0 auto; transform: translateY(-50%); /* 或者 */ /* position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); */ width: 100px; height: 100px; background-color: #fff; } .father3 { position: relative; margin-bottom: 10px; width: 300px; height: 300px; background-color: pink; } .son3 { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; background-color: #ccc; } .father4 { width: 300px; height: 300px; background-color: pink; } .son4 { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; background-color: pink; } 三栏布局\r#\rflex \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .container { display: flex; height: 200px; margin: 0 auto; } div \u0026gt; .left { width: 200px; background-color: burlywood; } div \u0026gt; .right { width: 200px; background-color: royalblue; } div \u0026gt; .main { /* flex布局 */ flex: 1; background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;left\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt;main\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;right\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; calc：通过CSS的calc可以动态计算中间部分的长度从而做到自适应，calc可以配合inline-block行内块级元素实现三栏布局，注意使用行内块级元素的时候如果编写HTML时换行，这个空白的换行也会作为元素解析从而会产生空白间隙，所以在编写时此处不要换行 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .container { /* display: flex; */ height: 200px; /* margin: 0 auto; */ } .container \u0026gt; div{ display: inline-block; height: 100%; color: #fff; } div \u0026gt; .left { width: 200px; background-color: burlywood; } div \u0026gt; .right { width: 200px; background-color: royalblue; } div \u0026gt; .main { /* flex布局 */ /* flex: 1; */ /* calc设置宽度 */ width: calc(100% - 400px); background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;left\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt;main\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;right\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; margin+float：使左右模块各自向左右浮动，并设置中间模块的margin值使中间模块宽度自适应。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Margin\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .container { height: 200px; border: 1px solid #eee; } .container div { color: #fff; height: 100%; } .container\u0026gt;.left { float: left; width: 200px; background-color: #19be6b; } .container\u0026gt;.main { margin-left: 200px; margin-right: 200px; background-color: #2979ff; } .container\u0026gt;.right { float: right; width: 200px; background-color: #fa3534; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;left\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;right\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt;main\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; "},{"id":4,"href":"/docs/vue/","title":"Vue笔记","section":"Docs","content":"\rVue笔记，等待完善ing\r#\r"},{"id":5,"href":"/docs/vue/note2/","title":"Vue组合式API","section":"Vue笔记","content":" 组合式API是一系列API的集合，使我们能够使用函数的方式书写组件，包括：\n响应式API：ref() reactive()等 生命周期钩子：onMounted() onUnmounted()等 依赖注入：provide() inject() setup() 钩子是在组件中使用组合式 API 的入口。在 setup() 函数中返回的对象会暴露给模板和组件实例。其他的选项也可以通过组件实例来获取 setup() 暴露的属性。\nsetup()\r#\rsetup() 函数是最早执行的，只执行一次，接收参数 组件的props 和 上下文context，返回 data 和 method。 props 是响应式的，为了在解构 props 时仍保持响应性，可以在 setup() 函数中使用 toRefs() 函数。 context 是普通对象，非响应式的。包含三个属性： attrs：接收父组件传递过来的，并且没有在props中声明的参数。 emit：用来在子组件中对父组件发送事件。在vue2中，子对父发送事件采用this.$emit；在vue3中，子组件对父组件发送事件采用 context.emit。 slots：（这个不太懂）。 响应式：核心\r#\rref()\r#\rhttps://juejin.cn/post/7225474899481051173\n用于将基本数据类型包装成响应式对象，ref是使用class里的get/set进行数据劫持和更新的。 .value 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。 在setup()里访问时，要加.value。从setup()里返回后，在模板里使用会自动解包，但是深层次的数据还是需要加.value才能访问。 reactive()\r#\r接收对象数据类型，使其成为响应式数据。\n响应式对象内的ref属性会被解包；响应式数组或 Map 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包： const count = ref(1) const obj = reactive({ count }) // ref 会被解包 console.log(obj.count === count.value) // true const books = reactive([ref(\u0026#39;Vue 3 Guide\u0026#39;)]) // 这里需要 .value console.log(books[0].value) const map = reactive(new Map([[\u0026#39;count\u0026#39;, ref(0)]])) // 这里需要 .value console.log(map.get(\u0026#39;count\u0026#39;).value) reactive的缺陷：\n参数只接受对象类型 Array Object Map Set 将属性赋值或解构到本地变量，或者传入一个函数时，会丧失响应性 原因：js没有可以作用域所有值类型的“引用” 解决：提供 ref() 为任何值类型的数据创建响应式，为 ref 对象包装一个.value属性 watch()\r#\r三个参数：侦听的响应式引用或getter函数、回调函数、配置选项（比如 immediate, deep, flush） 具有一定的惰性lazy，第一次页面展示的时候不会执行，只有数据变化的时候才会执行 只监听的给定的数据源 参数可以拿到当前值和原始值 watchEffect(副作用函数, 配置选项)\r#\r立即执行，没有惰性，页面的首次加载就会执行 不需要传递要侦听的内容 会自动感知代码依赖，不需要传递很多参数，只要传递一个回调函数 自动监听回调中所有能访问的响应式属性 只能获取当前值，不能获取之前数据的值 computed()\r#\r// 1.选项式写法 let firstName = ref(\u0026#34;yy\u0026#34;); let lastName = ref(\u0026#34;h\u0026#34;); let name = computed({ get() { return firstName.value + \u0026#34;-\u0026#34; + lastName.value; }, set(newVal) { [firstName.value, lastName.value] = newVal.split(\u0026#34;-\u0026#34;); }, }); const changeName = () =\u0026gt; { name.value = \u0026#34;l-cj\u0026#34;; }; // 2.函数式写法 let name1 = computed(() =\u0026gt; firstName.value + \u0026#34;-\u0026#34; + lastName.value); readonly()\r#\r接受一个对象 (响应式或纯对象) 或 ref 并返回原始对象的只读代理，不能修改只读副本。只读代理是深层的：任何被访问的嵌套 property 也是只读的。\nwatchPostEffect()\r#\rwatchEffect() 使用 flush: \u0026lsquo;post\u0026rsquo; 选项时的别名。\nwatchSyncEffect()\r#\rwatchEffect() 使用 flush: \u0026lsquo;sync\u0026rsquo; 选项时的别名。\n响应式：工具\r#\risRef()\r#\r检查某个值是否为 ref。\nunRef()\r#\r如果参数是 ref，则返回内部值，否则返回参数本身。\ntoRef()\r#\r可以将值、refs 或 getters 规范化为 refs。 在一个响应式对象里面，想把其中一个属性拿出来单独做响应式，可以使用toRef(obj, attrName)。\n用于响应式对象，修改响应式数据会影响到原始数据。 如果用于普通对象，则不具备响应式（数据的值改变了，但是视图不会变化）。 和ref的区别：ref本质是拷贝，修改响应式数据不会影响原始数据；toRef的本质是引用关系，修改响应式数据会影响原始数据。 toValue()\r#\r将值、refs 或 getters 规范化为值。\ntoRefs()\r#\r当需要解构响应式对象，且希望解构后的对象也保持响应性是，可以使用toRefs(reactiveObj)。\nisProxy()\r#\r检查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理。\nisReactive()\r#\r检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理。\nisReadonly()\r#\r检查传入的值是否为只读对象。只读对象的属性可以更改，但他们不能通过传入的对象直接赋值。\n响应式：进阶\r#\r响应式 API：进阶 | Vue.js\n生命周期钩子\r#\r组合式 API：生命周期钩子 | Vue.js\n注入依赖\r#\r组合式 API：依赖注入 | Vue.js onRenderTracked() 状态跟踪，会跟踪页面上所有响应式变量和方法的状态 onRenderTriggered() 状态触发，只有值变化时会触发该回调函数，明确给出新值和旧值\nprovide() \u0026amp; inject()\r#\r父级组件使用provide向下进行传递数据。 子级组件使用inject来获取上级组件传递过来的数据。 "},{"id":6,"href":"/docs/js/note1/","title":"函数柯里化和Promise","section":"JS笔记","content":"\r手写自动柯里化函数\r#\rfunction myCurrying(fn) { // args接收剩余参数 return function curryFn(...args) { // 判断当前参数数量是否大于等于fn的参数数量 // 大于等于：执行fn if (args.length \u0026gt;= fn.length) { // fn(...args); fn.apply(this, args); } // 否则：返回一个接收剩余参数的函数 else { return function (...newArgs) { // 在函数内部，拼接参数，递归 // return curryFn(...args, ...newArgs); return curryFn.apply(this, args.concat(newArgs)) } } } } function foo(x, y, z) { console.log(x + y + z); } var curryFoo = myCurrying(foo); var curry1 = curryFoo(10, 20); curry1(1); curryFoo(10)(20)(30); function logInfo(date, type, message) { console.log(`时间:${date} 类型:${type} 内容:${message}`); } var curryLogInfo = myCurrying(logInfo); var logToday = curryLogInfo(new Date()); logToday(\u0026#34;DEBUG\u0026#34;)(\u0026#39;修复一个错误\u0026#39;); Promise再学习！\r#\r理解\r#\rPromise是异步编程的解决方案（ES6）。从语法上看Promise是一个构造函数，从功能上看Promise封装异步操作并返回成功/失败的结果。 异步编程包括： fs 文件操作 数据库操作 AJAX 定时器 为什么要用Promise\r#\r支持链式调用，可以解决回调地狱问题（回调地狱层级太多，不便于阅读和错误处理） 指定回调函数的方式更加灵活（Promise启动异步任务=\u0026gt;返回Promise对象=\u0026gt;给Promise对象绑定回调函数） "},{"id":7,"href":"/docs/%E7%BD%91%E7%BB%9C/","title":"网络笔记","section":"Docs","content":"\r网络笔记，等待完善ing\r#\r"},{"id":8,"href":"/docs/js/note3/","title":"JS内置对象Array（一）","section":"JS笔记","content":"\r特征\r#\rJS数组大小是可以动态调整的（通过length属性），可以包含不同的数据类型 JS数组只能通过非负整数（和对应的字符串形式）作为索引访问 JS数组索引从0开始，最后一个元素索引是length-1 JS数组的复制操作会创建浅拷贝（所以JS对象的标准复制操作都会创建浅拷贝） 创建数组\r#\r构造函数 new Array()\n会根据传入的参数创建数组 当仅有一个参数arrayLength且为数字时，会创建arrayLength个空槽组成的数组 可以不使用new关键字 字面量 []\nconst fruits = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;]; 字符串对象原型上的方法 String.prototype.split()\nconst fruits3 = \u0026#34;Apple, Banana\u0026#34;.split(\u0026#34;, \u0026#34;); 创建二维数组\r#\r// 方法一 const arr = new Array(2).fill(0).map(() =\u0026gt; new Array(2).fill(0)); arr[0][0] = 1; // 正确 [ [ 1, 0 ], [ 0, 0 ] ] // 方法二(类似的for循环) const arr1 = new Array(); for(let i = 0; i \u0026lt; n; i++) { arr1.push([]); } 属性\r#\r原型 Array.prototype 上的属性：Array.prototype.constructor\n创建实例对象的构造函数 对于 Array 实例，初始值是 Array 构造函数。 实例自身的属性：length\n是Array的实例属性，反映数组中元素的数量 可修改 当length小于当前长度的值，超过length的元素会被删除 当length大于当前长度的值，将会用空槽拓展数组 当length属性为无效值，会引发RangeError 静态方法\r#\rArray.isArray()\n参数：一个值。 返回值：true或者false。用于确定传递的值是否是一个 Array。 Array.isarray() 拒绝原型链中带有 Array.prototype，而实际不是数组的对象，但 instanceof Array 会接受。判断一个变量是不是数组，最方便的方法是Array.isArray()\nArray.from(arrayLike [, mapFn, thisArg])\n参数：可迭代或类数组对象。可选参数是map函数和this上下文。 返回值：一个新的浅拷贝的数组实例。 Array.of()\n参数：可变数量的值。 返回值：一个新的 Array 实例，不考虑参数的数量或类型。 Array.of() 和 Array() 构造函数之间的区别在于对单个参数的处理：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个 length 为 7 的空数组（这意味着一个由 7 个空槽组成的数组，而不是由 7 个 undefined 组成的数组）。\n实例方法\tArray - JavaScript | MDN\r#\rArray.prototype.at(index)\n参数：索引值。接受负整数，从数组末尾开始计数，-1表示数组最后一个元素的索引。 返回值：给定索引处的数组元素。 如果 index \u0026lt; -array.length 或 index \u0026gt;= array.length，则总是返回 undefined。 Array.prototype.concat()\n参数：0个或多个数组。 返回值：一个新数组。 该数组将首先由调用它的对象中的元素填充。然后，对于每个参数，它的值将被连接到数组中——对于普通对象或基元，参数本身将成为最终数组的一个元素。concat方法是一种复制方法，返回浅拷贝。 Array.prototype.sort()\n对数组的元素进行排序，并返回对相同数组的引用。默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。由于它取决于具体实现，因此无法保证排序的时间和空间复杂度。 v8排序源码解析\n当数组长度小于等于10，采用插入排序。复杂度n^2。 大于10采用快排。通过对关键值的选取，能最大程度保证快排的复杂度趋近于平均复杂度，即nlogn。 "},{"id":9,"href":"/docs/","title":"Docs","section":"","content":""}]
[{"id":0,"href":"/docs/js/","title":"JS笔记","section":"Docs","content":"\rJS笔记，等待完善ing\r#\r"},{"id":1,"href":"/docs/%E7%BB%84%E4%BB%B6%E5%BA%93/note1/","title":"element-ui","section":"组件库笔记","content":"\relement-ui\r#\relementUI 源码-打造自己的组件库，系列二：Sass语法 BEM实现 Css编码规范_sass bem_海阔~天空的博客-CSDN博客\nSASS基本语法\r#\r变量\r#\r$variablename: value； !global 设置变量是全局的； !default 设置变量使用原值； 嵌套规则与属性\r#\r嵌套规则：通过缩进简写嵌套结构 nav { li { } ul { } } 嵌套属性：很多CSS属性有相同的前缀，可以嵌套来编写 font: { size : 18px; weight: bold; } @import 和 partials\r#\r不希望sass文件被编译为css文件，在文件名前面加上下划线 _文件名.sass 引用sass文件：@import \u0026ldquo;文件名\u0026rdquo;，如果文件名有下划线要去掉\n@mixin 和 @include\r#\rmixin（混入）可以定义一个能够重复使用的样式，能够接收参数(可以定义默认值)。 include 可以将混入定义的样式引入到文档中。\n@mixin important-text{ } @mixin b($color, $width) { border: $width solid $color; } .danger { @include important-text; @include b(red, 1px) } @extend 与继承\r#\r.button-basic { } .button-a { @extend .button-basic; } .button-b { @extend .button-basic; } @content\r#\r内容混入\n@mixin name { @content } @include name { ... //这里的内容会被加到上面的 @content 位置 } @at-root\r#\r@each in\r#\r@if @else\r#\r内置函数\r#\rmap-has-key($map, $key) map-get($map, $key) unquote($string) 删除引号 inspect($value) str-index($str, $value) 下标从1开始 str-slice($str, $value) SASS基本语法总结\r#\r父选择器引用：\u0026amp;代表父选择器简写，必须为前缀，否则sass会抛出错误 BEM——CSS命名规范（连接方式）\r#\r$namespace: \u0026rsquo;el\u0026rsquo;; // 所有的组件以el开头，如el-input $element-separator: \u0026lsquo;__\u0026rsquo;; // 元素以__分割，如el-input__inner $modifier-separator: \u0026lsquo;\u0026ndash;\u0026rsquo;; // 修饰符以\u0026ndash;分割，如el-input\u0026ndash;mini $state-prefix: \u0026lsquo;is-\u0026rsquo;; // 状态以is-开头，如is-disabled\nBEM实现\r#\r问题：hitAllSpecialNestRule判断父级选择器（$selector: \u0026amp;），是否包含\u0026ndash; .is- ：这三种字符，对应不同的处理方式，这里有点不太理解。\n/* BEM -------------------------- */ @mixin b($block) { $B: $namespace+\u0026#39;-\u0026#39;+$block !global; .#{$B} { @content; } } @mixin e($element) { $E: $element !global; $selector: \u0026amp;; $currentSelector: \u0026#34;\u0026#34;; @each $unit in $element { $currentSelector: #{$currentSelector + \u0026#34;.\u0026#34; + $B + $element-separator + $unit + \u0026#34;,\u0026#34;}; } @if hitAllSpecialNestRule($selector) { @at-root { #{$selector} { #{$currentSelector} { @content; } } } } @else { @at-root { #{$currentSelector} { @content; } } } } @mixin m($modifier) { $selector: \u0026amp;; $currentSelector: \u0026#34;\u0026#34;; @each $unit in $modifier { $currentSelector: #{$currentSelector + \u0026amp; + $modifier-separator + $unit + \u0026#34;,\u0026#34;}; } @at-root { #{$currentSelector} { @content; } } } 源码分析\r#\r基于js、vue实现，使用render函数或者组件模板（node_modules\\element-ui\\packages） 样式sass（node_modules\\element-ui\\packages\\theme-chalk\\src\\mixins）。 以 el-row 为例：\n/* 以下都是options选项 */ export default { /* 组件名 */ name: \u0026#39;ElRow\u0026#39;, componentName: \u0026#39;ElRow\u0026#39;, props: { /* 默认是div元素 */ tag: { type: String, default: \u0026#39;div\u0026#39; }, /* 列间距，在el-row左右两侧各添加一个gutter值/2的外边距 */ gutter: Number, type: String, justify: { type: String, default: \u0026#39;start\u0026#39; }, align: String }, computed: { style() { const ret = {}; if (this.gutter) { ret.marginLeft = `-${this.gutter / 2}px`; ret.marginRight = ret.marginLeft; } return ret; } }, render(h) { return h(this.tag, { class: [ \u0026#39;el-row\u0026#39;, this.justify !== \u0026#39;start\u0026#39; ? `is-justify-${this.justify}` : \u0026#39;\u0026#39;, this.align ? `is-align-${this.align}` : \u0026#39;\u0026#39;, { \u0026#39;el-row--flex\u0026#39;: this.type === \u0026#39;flex\u0026#39; } ], style: this.style }, this.$slots.default); } }; @import \u0026#34;common/var\u0026#34;; @import \u0026#34;mixins/mixins\u0026#34;; @import \u0026#34;mixins/utils\u0026#34;; @include b(row) { position: relative; box-sizing: border-box; @include utils-clearfix; @include m(flex) { display: flex; \u0026amp;:before, \u0026amp;:after { display: none; } @include when(justify-center) { justify-content: center; } @include when(justify-end) { justify-content: flex-end; } @include when(justify-space-between) { justify-content: space-between; } @include when(justify-space-around) { justify-content: space-around; } @include when(align-top) { align-items: flex-start; } @include when(align-middle) { align-items: center; } @include when(align-bottom) { align-items: flex-end; } } } 使用\r#\rLayout布局\r#\r\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;layout\u0026#34;\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-col :span=\u0026#34;24\u0026#34;\u0026gt; 24 \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-col :span=\u0026#34;18\u0026#34;\u0026gt; 18 \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;el-row :gutter=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;6\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;background-color: turquoise;\u0026#34;\u0026gt; 6 \u0026lt;/div\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;6\u0026#34;\u0026gt; 6 \u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;6\u0026#34;\u0026gt; 6 \u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;6\u0026#34;\u0026gt; 6 \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;el-row type=\u0026#34;flex\u0026#34; justify=\u0026#34;space-between\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;6\u0026#34;\u0026gt; 6 \u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;6\u0026#34;\u0026gt; 6 \u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;6\u0026#34;\u0026gt; 6 \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;el-row type=\u0026#34;flex\u0026#34; justify=\u0026#34;space-around\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;6\u0026#34;\u0026gt; 6 \u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;6\u0026#34;\u0026gt; 6 \u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;6\u0026#34;\u0026gt; 6 \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .el-row { background-color: pink; margin: 20px 0; box-sizing: border-box; } .el-col { background-color: rgb(39, 82, 28); color: white; padding: 10px 0; border-right: 2px #ccc solid; } \u0026lt;/style\u0026gt; Container容器\r#\rel-container(如果有el-header或者el-footer，排列方向是vertical，子元素会垂直上下排列。)\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-header\u0026gt;header\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside\u0026gt;aside\u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt;main\u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;el-footer\u0026gt;footer\u0026lt;/el-footer\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .el-container { background-color: #ccc; color: white; } .el-header { background-color: #B3C0D1; } .el-main { background-color: pink; } .el-aside { min-width: 200px; min-height: 350px; background-color: rgb(190, 121, 121); } .el-footer { background-color: rgb(145, 136, 136); } \u0026lt;/style\u0026gt; Icon和Link\r#\ricon：标签，设置类名为el-icon-iconName来使用（class=\u0026ldquo;el-icon-iconName\u0026rdquo;，在中写对应的样式；一开始写成了 icon=\u0026ldquo;el-icon-iconName\u0026rdquo;，.el-icon-iconName中的样式没有生效） link文字链接：标签 "},{"id":2,"href":"/docs/hugo/note1/","title":"hugo建站","section":"Hugo笔记","content":"\r前言\r#\r在工作和学习中，我们经常会使用新的技术工具、学习新的知识点，也会解决一些开发中的技术问题，自然少不了写博客记录的环节。写博客能够帮助我们自身强化知识点、提升学习能力、提升文字组织能力和逻辑思维能力；发布博客能够让我们向外界展示自己，向更多人分享经验，进行更多的讨论交流。 我们可以搭建属于自己的个人博客网站，只需上传笔记和文章，就能够随时随地访问和分享自己的产出。可以用来搭建博客的工具有很多，下表展示了建站工具hugo、wordpress、hexo在不同方面的表现。从表中可见，Hugo具有安装便捷、操作简单、部署方便等诸多优点，并且访问速度非常快，能够极大地优化写作发布体验。因此，我在搭建个人博客时使用 Hugo + GitHub Pages 的组合来完成，无需服务器即可拥有自己的博客天地。本文主要介绍使用Hugo搭建个人博客的步骤以及阅读总结。\nHugo安装与使用\r#\rHugo是什么\r#\rHugo 是一个用 Go 语言编写的快速而现代的静态网站生成器，它是一个通用的网站框架，旨在为网站的最终用户提供最佳的浏览体验，并为网站作者提供理想的写作体验。从技术上讲，Hugo是一个静态站点生成器，用 Hugo 建立的网站非常快速和安全。Hugo网站可以托管在任何地方，包括netflix, Heroku, GoDaddy, DreamHost, GitHub Pages, GitLab Pages, Surge, Firebase, Google Cloud Storage, Amazon S3, Rackspace, Azure和CloudFront，并与 cdn 配合良好。Hugo 站点的运行不需要数据库，具有几乎即时的构建时间，能够在任何更改时进行重建。 通过 Hugo 我们可以快速搭建静态网站，比如博客系统、文档介绍、公司主页、产品介绍等等。相对于其他静态网站生成器来说，Hugo 具备如下特点：\n极快的页面编译生成速度。（ \u0026lt; 1 ms 每页面） 完全跨平台支持，可以运行在 Mac OS X, Linux, Windows, 以及更多! 安装方便。 本地调试时通过 LiveReload 自动即时刷新页面。 主题支持。 可以部署在任何的支持 HTTP 的服务器上。 搭建与使用\r#\r此处的安装步骤在Win10上进行。 安装Hugo\r#\r下载适合操作系统的版本压缩包，下载地址：Releases · gohugoio/hugo。 解压并把 hugo.exe 的目录加到环境变量 PATH 中。（设置\u0026gt;系统-\u0026gt;关于（或我的电脑-\u0026gt;属性）\u0026gt;高级系统设置\u0026gt;高级\u0026gt;环境变量\u0026gt;PATH） 执行命令 hugo version，验证安装是否成功，有如下输出则代表成功。 hugo v0.86.1-F6821B88 windows/amd64 BuildDate=2021-07-30T10:13:35Z VendorInfo=gohugoio 执行命令 hugo help 可以查看 Hugo 的基本使用方法。 hugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: config Print the site configuration convert Convert your content to different formats deploy Deploy your site to a Cloud provider. env Print Hugo version and environment info gen A collection of several useful generators. help Help about any command import Import your site from others. list Listing out various types of content mod Various Hugo Modules helpers. new Create new content for your site server A high performance webserver version Print the version number of Hugo Flags: -b, --baseURL string hostname (and path) to the root, e.g. http://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/ --cleanDestinationDir remove files from destination not found in static directories --config string config file (default is path/config.yaml|json|toml) --configDir string config dir (default \u0026#34;config\u0026#34;) -c, --contentDir string filesystem path to content directory --debug debug output -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date and author info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo --i18n-warnings print missing translations --ignoreCache ignores the cache directory --ignoreVendor ignores any _vendor directory --ignoreVendorPaths string ignores any _vendor for module paths matching the given Glob pattern -l, --layoutDir string filesystem path to layout directory --log enable Logging --logFile string log File path (if set, logging enabled automatically) --minify minify any supported output format (HTML, XML etc.) --noChmod don\u0026#39;t sync permission mode of files --noTimes don\u0026#39;t sync modification time of files --path-warnings print warnings on duplicate target paths etc. --poll string set this to a poll interval, e.g --poll 700ms, to use a poll based approach to watch for file system changes --print-mem print memory usage to screen at intervals --quiet build in quiet mode --renderToMemory render to memory (only useful for benchmark testing) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMetrics -t, --theme strings themes to use (located in /themes/THEMENAME/) --themesDir string filesystem path to themes directory --trace file write trace to file (not useful in general) -v, --verbose verbose output --verboseLog verbose logging -w, --watch watch filesystem for changes and recreate as needed Additional help topics: hugo check Contains some verification checks Use \u0026#34;hugo [command] --help\u0026#34; for more information about a command. 新建Hugo站点\r#\r执行命令 hugo new site example，成功后会显示： Congratulations! Your new Hugo site is created in 目录/example. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 我们可以查看目录结构 ├── archetypes │ └── default.md ├── config.toml # 配置文件 ├── content # 博客文章目录 ├── data ├── layouts # 网站布局 ├── static # 静态内容 └── themes # 主题 执行命令 hugo server 本地预览，打开浏览器可能会看到 Page Not Found ，这是因为 Hugo 没有默认主题无法显示，执行下面的命令安装一个主题并运行： git clone https://github.com/spf13/hyde.git themes\\hyde hugo serve -D -t hyde 创建文章\r#\r使用命令 hugo new path/name.md 可以创建一个内容页面，新创建的文件默认在目录 content/ 里。 举个例子： 使用命令 hugo new about.md 创建文章，新创建的文件默认在目录 content/ 里，会自动生成如下内容，一般称为 \u0026ldquo;front matter\u0026rdquo; 前言部分： --- title: \u0026#34;About\u0026#34; date: 2023-09-01T12:12:20+08:00 draft: true --- 在 \u0026mdash; 下面，用 Markdown 格式写一点内容，如： show me 本地预览查看创建的文章，默认显示 content 目录下的所有文章： 添加主题\r#\r此时，我们已经创建属于自己的博客项目并已经添加了文章。在创建文章之前，我们可以为项目添加一个主题样式，实现更丰富的展示效果。Hugo 社区 中有各种各样的主题，可以自由地选择模板。这里以主题 hugo-book 为例，我们可以在官网找到安装的命令：\n进入 hugo 项目的根目录并执行： // 安装主题 git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book // 将主题的例子拷贝到hugo的content目录下 cp -R themes/hugo-book/exampleSite/content.en/* ./content 运行项目（在根目录的配置文件 hugo.toml 中设置 theme = \u0026ldquo;hugo-book\u0026rdquo;/theme: hugo-book 指定主题）： // \u0026#39;--theme hugo-book\u0026#39; 指定主题 hugo server --theme hugo-book 查看主题已生效 我在运行项目的时候遇到报错：failed to transform \u0026ldquo;book.scss\u0026rdquo; (text/x-scss)，这个问题可以通过安装 hugo-extend 版本解决，安装后重复上述流程即可。 新建GitHub库\r#\r新建一个空的git仓库，仓库名称为 userName.github.io，注意这里的 userName 要与GitHub账号的用户名保持一致。 记住仓库路径 https://github.com/userName/userName.github.io 部署\r#\rGitHub Pages是GitHub提供的一个网页寄存服务，可以寄存静态页面，这个特性特别适合博客的搭建。具体步骤如下：\n将 hugo.toml (config.toml) 中的 baseURL 改为想要访问的地址：baseURL = \u0026lsquo;https://userName.github.io/\u0026rsquo;。 在根目录下的终端执行命令 hugo，会生成 public 文件夹，里面就是要上传到 GitHub 仓库的内容。 在 public 文件夹下打开 git bash，运行以下命令： git init git add -A git commit -am\u0026quot;init\u0026quot; git remote add origin https://github.com/hyylc/userName.github.io git push -f origin master（网络问题上传不了就多上传几次） 如果提交后远程仓库出现“There isn\u0026rsquo;t anything to compare.”显示没有可以合并的内容，可以按照下面的步骤把代码放在main分支下并提交到远程仓库。 # 切换分支至master git checkout master # 强制重命名master分支为main分支 git branch main master -f # 切换分支至main git checkout main # 强制推送本地main分支至远程库，并覆盖远程main分支内容 git push origin main -f 在浏览器输入网址 https://userName.github.io/ 即可访问部署后的网站。 更新博客\r#\r在本地 Hugo 站点中添加或修改文章。 在根目录下的终端输入 hugo，即可更新 public 文件夹。 进入 public 文件夹，向远程仓库提交对本地的更改。 Hugo 如何编译 markdown\r#\r经过上述步骤，我们已经成功搭建属于自己的个人博客并部署完成。Hugo具有出色的Markdown支持，只要将 markdown 格式编写的文章添加到本地项目中并推到 GitHub 仓库，就可以更新博客。在这个过程中，我产生了疑问：Hugo 是如何将我们编写的 .md 文件解析成 HTML 并展示到页面上的呢？通过查看 Hugo 的官网，我了解到 Hugo 将默认的 Markdown 解析器设置成了 Goldmark ，那么问题转化成了：Goldmark 是如何将 Markdown 转换成HTML的呢？我们从 AST 和 CommonMark 规范开始说起。\nAST\r#\rAST，全称为抽象语法树（Abstract Syntax Tree），是用于表示程序代码或其他结构化文本的一种树状数据结构，通过节点和连接的方式来表示代码中的各个部分以及它们之间的关系。抽象语法树在编译器中的应用包括语法分析、语义分析、优化和代码生成等。在解析 Markdown、HTML 或其他结构化文本时，也可以使用抽象语法树来表示文本的结构。 举个例子，考虑以下的算术表达式：3 + 4 * 5。对应的抽象语法树可能是这样的：\n+ / \\ 3 * / \\ 4 5 在这个 AST 中，根节点是加法运算符，左子节点是数字 3，右子节点是乘法运算符，其左右子节点分别是数字 4 和 5。\nCommonMark 规范\r#\rCommonMark 是一个强定义的 Markdown 规范，它对很多细节做出定义，避免歧义性，这样一来，写 Markdow 解释器和转换器就比较简单了。 在 CommonMark 规范中，解析 Markdown 的一般过程如下：\n词法分析： 首先，Markdown 文本会被词法分析器拆分成词法单元，例如标记、符号、文本等。词法分析器会根据字符和符号的规则将文本分成一系列的单元。 语法解析： 接下来，语法解析器会根据 CommonMark 的语法规则将词法单元组合成更高层次的语法结构，例如段落、标题、列表、代码块等。这个阶段会构建出抽象语法树（AST）。 生成抽象语法树（AST）： AST 是一个表示 Markdown 文本结构的树状数据结构。每个节点代表一个文本块，例如段落、标题、链接等。节点之间的层次关系和父子关系表示了文本的结构。 渲染： 根据生成的抽象语法树，可以将 Markdown 文本渲染成其他格式，如 HTML。不同节点类型会被映射到相应的 HTML 元素，从而实现文本在不同格式间的转换。 不同的编程语言和库可以实现自己的 CommonMark 解析器。例如 commonmark.js、commonmark-java、cmark等，这些库都提供了用于解析和渲染 Markdown 的方法和接口。而我们讨论的 Goldmark 就是用 Go 语言编写的 Markdown 解析器。还记得吗？Hugo 是一个用 Go 语言编写的快速而现代的静态网站生成器。使用这些解析器就可以实现 markdown 语法到 HTML 的转换，例如标题（#）和段落会被转换为对应的 HTML 的 和 标签、无序列表（- 或 *）和有序列表（数字加点）会被转换为 HTML 的 和 列表、链接和图片语法会被转换为 HTML 的 和 标签等等。\nGoldmark\r#\rGoldmark 的核心思路是将输入的 Markdown 文本解析为一个抽象语法树（AST），然后根据这个 AST 进行进一步的处理和渲染。两个关键步骤就是解析和渲染。\n解析器\r#\r在 Goldmark 中，解析 Markdown 文本的核心方法是 Parse，该方法用于将 Markdown 文本转换为抽象语法树（AST）。下面是关于 Parse 方法的一些细节：\nimport ( \u0026#34;github.com/yuin/goldmark\u0026#34; \u0026#34;github.com/yuin/goldmark/parser\u0026#34; \u0026#34;github.com/yuin/goldmark/text\u0026#34; ) func main() { // 创建 Markdown 解析器 md := goldmark.New( // 可以设置各种配置选项 ) // 要解析的 Markdown 文本 markdownText := \u0026#34;# Hello, World!\u0026#34; // 将 Markdown 文本转换为字符串读取器 source := text.NewReader([]byte(markdownText)) // 创建解析器上下文 context := parser.NewContext() // 解析 Markdown 文本并获得 AST rootNode := md.Parser().Parse(source, parser.WithContext(context)) // 现在你可以处理 rootNode，遍历 AST 进行操作 // ... } 主要步骤如下：\n创建解析器实例： 使用 goldmark.New() 创建一个 goldmark.Markdown 的实例，该实例将用于解析和渲染 Markdown 文本。创建实例时可以设置各种配置选项，以控制解析器的行为。 创建字符串读取器： 使用 text.NewReader([]byte(markdownText)) 将 Markdown 文本转换为 Goldmark 支持的字符串读取器。字符串读取器是一个用于处理文本的 Goldmark 内部类型。 创建解析器上下文： 使用 parser.NewContext() 创建一个解析器上下文，用于保存解析过程中的临时状态的结构。 解析 Markdown 文本： 使用 md.Parser().Parse(source, parser.WithContext(context)) 方法将 Markdown 文本解析成抽象语法树（AST）。解析过程中会根据 Markdown 文本的结构和语法规则生成对应的 AST 节点。 解析后的 AST 节点树可以被进一步处理和渲染，以生成最终的 HTML 输出。 渲染器\r#\rGoldmark 中将 AST 节点树转换为 HTML 是通过使用渲染器（renderer）来实现的。Goldmark 提供了一种机制，我们可以根据需要为不同类型的节点定义自定义的渲染器，然后在解析过程中自动应用这些渲染器，将 AST 节点转换为相应的 HTML。下面是一个简单的示例，md.Convert 方法会自动应用默认的 HTML 渲染器，将 AST 节点转换为 HTML 格式：\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/yuin/goldmark\u0026#34; \u0026#34;github.com/yuin/goldmark/renderer/html\u0026#34; \u0026#34;log\u0026#34; ) func main() { // 创建 Markdown 解析器 md := goldmark.New() // 要解析的 Markdown 文本 markdownText := \u0026#34;# Hello, *World*!\u0026#34; // 解析 Markdown 文本并获得 AST var buf bytes.Buffer if err := md.Convert([]byte(markdownText), \u0026amp;buf); err != nil { log.Fatal(err) } // 输出转换后的 HTML fmt.Println(buf.String()) } 例子\r#\rHugo 将默认的 Markdown 解析器设置成了 Goldmark，通过上述过程解析我们编写的 markdown 文件，并最终渲染成 HTML，成为我们在浏览器中看到的内容。我们可以通过下面的在线样例，查看构建的AST树、最终的HTML文件和渲染效果。\n原始 Markdown 文件： # 一级标题 ## 二级标题 解析的 AST 树： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE document SYSTEM \u0026#34;CommonMark.dtd\u0026#34;\u0026gt; \u0026lt;document xmlns=\u0026#34;http://commonmark.org/xml/1.0\u0026#34;\u0026gt; \u0026lt;heading level=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;text\u0026gt;一级标题\u0026lt;/text\u0026gt; \u0026lt;/heading\u0026gt; \u0026lt;heading level=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;text\u0026gt;二级标题\u0026lt;/text\u0026gt; \u0026lt;/heading\u0026gt; \u0026lt;/document\u0026gt; 生成的 HTML 文件： \u0026lt;h1\u0026gt;一级标题\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;二级标题\u0026lt;/h2\u0026gt; 预览效果： Hugo plugin /Hugo themes的基础了解\r#\rHugo 中的插件（plugins）和主题（themes）都是用于扩展和定制 Hugo 网站的重要工具，官方网站上有大量成熟的插件和主题，也提供了详细的文档来帮助自定义开发插件和主题。\nHugo plugins\r#\rHugo 插件是一些额外的代码模块，可以被集成到 Hugo 网站中，以提供额外的功能或修改现有功能。插件可以用于从各种外部数据源获取内容、优化网站性能、添加自定义功能等。插件允许我们通过几行代码来实现复杂的任务，无需手动编写大量代码。使用插件需要在 Hugo 网站的根目录下的 config.toml文件中的 plugins 部分声明你想要使用的插件。一旦插件安装好并在配置文件中设置，Hugo 就会自动应用插件的功能，可能会修改输出的页面、添加新的短代码、生成额外的资源等等。 下面这个示例演示了如何使用 hugo-mod-bootstrap 插件：\n安装插件：打开 Hugo 网站根目录下的 config.toml 文件，添加插件的信息： [plugins] hugo-mod-bootstrap = \u0026#34;github.com/davidsneighbour/hugo-mod-bootstrap\u0026#34; 使用插件：在某个 Markdown 内容中，使用插件提供的短代码来引入 Bootstrap 组件。比如，在 about.md 中使用 figure 短代码来创建一个带有 Bootstrap 样式的图像： --- title: \u0026#34;About\u0026#34; date: 2023-09-01T12:12:20+08:00 draft: true --- show me 运行 Hugo，查看插件效果 Hugo themes\r#\rHugo 主题是预先设计好的模板和样式，用于定制网站的外观和布局。通过使用主题可以轻松地应用一整套设计风格，无需从头开始编写网站的样式和布局。主题通常包括模板文件、CSS 样式、JavaScript 脚本等，能够快速构建出具有吸引力的网站。要使用主题需要将主题的文件夹放置在 Hugo 网站的 themes 目录下，然后在配置文件中设置所选主题的名称，Hugo 将应用主题的模板、样式等内容。 除了安装和配置 theme 参数之外，每个主题都有自己的配置选项，允许我们自定义主题的外观和功能。此外，在创建新的内容时，我们可以使用主题提供的布局、短代码等。这些内容需要我们去阅读主题的文档来进一步了解。以 Hugo book 为例，在使用该主题时我们可以在 config.toml 文件中添加以下配置选项：\n#（可选，默认浅色）设置颜色主题：浅色、深色或自动。 BookTheme = \u0026#39;light\u0026#39; #（可选，默认为 true）控制页面右侧的目录可见性。 BookToC = true #（可选，默认无）设置图书徽标的路径。如果图片是/static/logo.png，那么路径将是\u0026#39;logo.png\u0026#39; BookLogo = \u0026#39;logo.png\u0026#39; #（可选，默认文档）指定要呈现为菜单的内容部分 # 也可以将值设置为“*”，将所有部分渲染到菜单 BookSection = \u0026#39;docs\u0026#39; 实际效果\r#\r下面是使用 Hugo book 主题的 Hyy小站，目前我简单整理了几篇学习笔记，效果图如下： 移动端效果： 网页端效果： 参考\r#\rWhat is Hugo Markdown render hooks Hugo-Book Gitee 极速下载/goldmark Hugo的Markdown文件是如何被翻译成HTML的 - 掘金 CommonMark 0.30 "},{"id":3,"href":"/docs/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/note1/","title":"Vite \u0026 Pinia","section":"开发工具","content":"\rVite\r#\r前端构建工具 相较于webpack（先打包再运行），vite采用了不同的运行方式： 开发时，并不对项目进行打包，而是直接采用ESM（ES模块）的方式来运行项目 在项目部署时，对项目进行打包，部署到服务器 除了速度快，vite使用也更方便 基本使用： 安装开发依赖 yarn vite vue的源码目录就是项目根目录 开发命令： vite 启动开发服务器 vite build 打包代码 vite preview 预览打包后代码\n使用命令构建 npm create vite@latest yarn create vite pnpm create vite index.html引入脚本要加上type=\u0026ldquo;module\u0026rdquo; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/svg+xml\u0026#34; href=\u0026#34;/vite.svg\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Vite + Vue\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/src/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 配置文件：vite.config.js import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], }) Pinia\r#\r修改state数据的五种方法\r#\r\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;{{test.name}}\u0026lt;/span\u0026gt;--- \u0026lt;span\u0026gt;{{test.current}}\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;change\u0026#34;\u0026gt;change\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref, reactive, computed, watchEffect } from \u0026#34;vue\u0026#34;; import { getCurrentInstance } from \u0026#34;vue\u0026#34;; import HelloWorldVue from \u0026#34;./components/HelloWorld.vue\u0026#34;; import { useMouse } from \u0026#34;./components/MouseMove/index.js\u0026#34;; import {useStore} from \u0026#39;./store/index.js\u0026#39; // 仓库 const test = useStore(); const change = () =\u0026gt; { // 方式一 // test.current++ // 方式二 // test.$patch({ // current: 888, // name: \u0026#39;hyy888\u0026#39; // }) // 方式三，函数写法 // test.$patch((state) =\u0026gt; { // state.current = 999; // state.name = \u0026#39;hyy999\u0026#39;; // }) // 方法四，缺点：必须要修改整个对象 // test.$state = { // current: \u0026#39;111\u0026#39;, // name: \u0026#39;hyy111\u0026#39; // } // 方式五：通过action修改 test.setCurrent() } 解构store\r#\rpinia解构失去响应式 解决方法：storeTorefs(test) API\r#\r$reset() $subscribe((args, state)=\u0026gt;{}) state中值变化，就会触发函数，返回一个工厂函数 $onAction((args) =\u0026gt; {}) 第一个参数是工厂函数 $patch((state) =\u0026gt; {}) "},{"id":4,"href":"/docs/vue/note3/","title":"Vue3.0 基础","section":"Vue笔记","content":"\r快速开始\r#\rnpm run dev执行的过程\r#\rVue开发命令 npm run dev 输入后的执行过程_微 光的博客-CSDN博客 npm run dev 的时候究竟做了什么_npm_蚂蚁二娘-华为云开发者联盟\nvue3 书写风格\r#\roptions API setup() setup语法糖， ref全家桶\r#\rref 包裹变量的值，实现深层次响应式 isRef 判断是否是Ref对象 shallowRef 只能实现浅层式的响应（ref和shallowRef不能写在一起，会被ref影响） triggerRef 强制更新 customRef 自定义Ref ref 可以用来获取dom元素，就不用document.get\u0026hellip;等方式获取了 reactive全家桶\r#\r参数只接受引用类型 访问修改不需要加.value reactive直接给数组对象赋值，会破坏响应式对象，视图不会更新，不能响应式地渲染到页面上，解决方法 方法一：解构赋值，push到数组中 方法二：添加一个对象，将数组作为一个属性，这样赋值就没问题 readonly 只读属性，不允许赋值 shallowReactive 浅层响应，更深层次的变化不会渲染到页面，也会被reactive影响（类似shallowRef） ref和reactive的区别：\r#\rref支持所有的类型；reactive参数只接受引用类型（Array Object Map Set） ref取值、赋值都需要加.value；reactive不需要.value to全家桶\r#\rtoRef() 用于提取对象的某个属性，解构拿到属性传递给函数。注意：只有用于修改响应式对象的值时页面才会有变化，非响应式视图毫无变化 toRefs 解构reactive，可以使对象的每个属性都是响应式对象 toRaw 是对象不再是响应式对象 vue3响应式原理（见笔记）\r#\rcomputed计算属性\r#\r当依赖的值发生变化，计算属性会自动更新。\n选项式写法，支持一个对象里面写get函数和set函数 函数式写法，只能支持一个getter函数，不允许修改值 // 1.选项式写法 let firstName = ref(\u0026#39;yy\u0026#39;); let lastName = ref(\u0026#39;h\u0026#39;); let name = computed({ get () { return firstName.value + \u0026#39;-\u0026#39; + lastName.value; }, set (newVal) { [firstName.value, lastName.value] = newVal.split(\u0026#39;-\u0026#39;); } }) const changeName = () =\u0026gt; { name.value = \u0026#39;l-cj\u0026#39;; } // 2.函数式写法 let name1 = computed(() =\u0026gt; firstName.value + \u0026#39;-\u0026#39; + lastName.value) watch监听器（再看看官网）\r#\r监听响应式对象的变化，如果要监听ref对象的深度监听属性要开启watch的deep属性，reactive对象不需要。 属性：deep（深度监听）/immediate（为true会在一开始的时候执行一次回调函数）/flush(pre组件更新之前调用，sync同步执行，post组件更新之后执行)\nwatchEffect高级监听器\r#\r监听数据变化，立即执行回调函数\n认识组件和生命周期\r#\r\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;我是组件\u0026lt;/h3\u0026gt; \u0026lt;div ref=\u0026#39;div\u0026#39;\u0026gt;{{str}}\u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; import {onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted} from \u0026#39;vue\u0026#39; // 可以用来调试 import {onRenderTriggered, onRenderTracked} from \u0026#39;vue\u0026#39; // setup语法糖模式没有 beforeCreate, created这两个生命周期 let str = ref(\u0026#39;hyy\u0026#39;) let div = ref() console.log(\u0026#39;setup\u0026#39;); onBeforeMount(() =\u0026gt; { console.log(\u0026#39;创建之前\u0026#39;, div.value); }) onMounted(() =\u0026gt; { console.log(\u0026#39;创建完成\u0026#39;, div.value); }) onBeforeUpdate(() =\u0026gt; { console.log(\u0026#39;更新组件之前\u0026#39;); }) onUpdated(() =\u0026gt; { console.log(\u0026#39;更新组件完成\u0026#39;); }) onBeforeUnmount(() =\u0026gt; { console.log(\u0026#39;销毁组件之前\u0026#39;); }) onUnmounted(() =\u0026gt; { console.log(\u0026#39;销毁组件完成\u0026#39;); }) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .read-the-docs { color: #888; } \u0026lt;/style\u0026gt; bem布局和经典layout架构\r#\r父子组件传参\r#\rdefineProps 子组件接受父组件传递的值 defineEmits 给父组件传值 const emit = defineEmits([\u0026lsquo;on-click\u0026rsquo;])，父组件监听这个时间 defineExpose 暴露属性、方法\n// 子组件接收父组件传递的值 const props = defineProps({ name : { type: String, default: \u0026#39;hyy\u0026#39; } }) // 给父组件传值 const emit = defineEmits([\u0026#39;on-click\u0026#39;]) const send = () =\u0026gt; { emit(\u0026#39;on-click\u0026#39;, \u0026#39;lcj\u0026#39;) } 局部组件和全局组件、动态组件\r#\r异步组件\r#\r应用场景：请求到数据之前给用户展示骨架屏\nTeleport传递组件\r#\rkeep-alive缓存组件\r#\r动态组件\r#\rtransition组件\r#\r在样式中写过渡效果 可以配合第三方库，如 animate.css 等实现更多效果 生命周期函数： before-enter enter after-enter enter-cancelled before-leave leave after-leave leave-cancelled gsap库 appear 首次渲染执行动画 transition-group过渡列表\r#\r平面过渡 状态过渡 依赖注入\r#\r兄弟组件传参和事件总线\r#\r借助父组件传递参数 手写事件总线eventBus（基于发布订阅模式） Bus.emit(自定义事件, 参数\u0026hellip;)发射 Bus.on(自定义事件, 回调函数)监听 Bus.off(取消自定义事件, 取消回调函数) Bus.all.clear() 取消所有事件 mitt 组件\r#\r内置组件\r#\r#\r为单个元素或组件提供动画过渡效果 props 生命周期函数 #\r对多个元素、组件添加动画效果 列表中每个元素都要有唯一的key #\r缓存组件，使其不被销毁，保留状态 #\r通过 to 将组件渲染到指定的DOM结构处 #\r对异步依赖进行处理，上层等待下层，可以在等待时渲染一个加载状态 深入组件\r#\r透传 Attributes\r#\rclass与style：没有被组件声明为props和emits的属性或事件监听器，会被添加到组件的根元素上。如果已经有class或style属性，会和继承的值合并。 v-on监听器：会被添加到组件的根元素上。 深层组件：可以被传递到根节点渲染的组件上，其中被声明过的props和emit事件不会向深层传递。 可以通过 $attr 控制透传进来的属性，包括组件声明的props emit，和class、style、v-on等等。 子组件元素中显示绑定 $attr ：click me。 在JS中访问透传属性： \u0026lt;script setup\u0026gt; import { useAttrs } from \u0026#39;vue\u0026#39; const attrs = useAttrs() \u0026lt;/script\u0026gt; vue3.3 设置属性禁用继承： \u0026lt;script setup\u0026gt; defineOptions({ inheritAttrs: false }) // ...setup 逻辑 \u0026lt;/script\u0026gt; 插槽\r#\r渲染作用域 默认插槽 具名插槽：要为具名插槽传入内容，需要使用一个含 v-slot 指令（对应简写#）的 元素，并将目标插槽的名字传给该指令 作用域插槽 默认插槽 \u0026lt;MyComponent v-slot=\u0026#34;slotProps\u0026#34;\u0026gt; {{ slotProps.text }} {{ slotProps.count }} \u0026lt;/MyComponent\u0026gt; 具名插槽 \u0026lt;MyComponent\u0026gt; \u0026lt;template #header=\u0026#34;headerProps\u0026#34;\u0026gt; {{ headerProps }} \u0026lt;/template\u0026gt; \u0026lt;template #default=\u0026#34;defaultProps\u0026#34;\u0026gt; {{ defaultProps }} \u0026lt;/template\u0026gt; \u0026lt;template #footer=\u0026#34;footerProps\u0026#34;\u0026gt; {{ footerProps }} \u0026lt;/template\u0026gt; \u0026lt;/MyComponent\u0026gt; 列表展示案例 依赖注入\r#\rprovide import { provide } from \u0026#39;vue\u0026#39; export default { setup() { provide(/* 注入名 */ \u0026#39;message\u0026#39;, /* 值 */ \u0026#39;hello!\u0026#39;) } } inject \u0026lt;script setup\u0026gt; import { inject } from \u0026#39;vue\u0026#39; const message = inject(\u0026#39;message\u0026#39;) \u0026lt;/script\u0026gt; 异步组件（配合suspend内置组件，再看看）\r#\r逻辑复用\r#\r组合式函数\r#\r封装和复用有状态逻辑的函数，例如鼠标跟踪器。\nimport { ref, onMounted, onUnmounted } from \u0026#34;vue\u0026#34;; export function useMouse() { const x = ref(0); const y = ref(0); function update(event) { x.value = event.pageX; y.value = event.pageY; } onMounted(() =\u0026gt; { window.addEventListener(\u0026#39;mousemove\u0026#39;, update); }) onUnmounted(() =\u0026gt; { window.removeEventListener(\u0026#39;mousemove\u0026#39;, update); }) return { x, y } } 自定义指令\r#\r\u0026lt;template\u0026gt; \u0026lt;div v-move id=\u0026#34;box\u0026#34;\u0026gt;我是盒子\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref, reactive, computed, watchEffect } from \u0026#34;vue\u0026#34;; import { getCurrentInstance } from \u0026#34;vue\u0026#34;; import HelloWorldVue from \u0026#34;./components/HelloWorld.vue\u0026#34;; import { useMouse } from \u0026#34;./components/MouseMove/index.js\u0026#34;; // 移动组件 const vMove = (el, binding) =\u0026gt; { console.log(el, binding); const mouseDown = () =\u0026gt; { const move = (e) =\u0026gt; { console.log(111); console.log(el); el.style.color = \u0026#34;red\u0026#34; el.style.left = e.clientX + \u0026#39;px\u0026#39;; el.style.top = e.clientY + \u0026#39;px\u0026#39;; } document.addEventListener(\u0026#39;mousemove\u0026#39;, move); document.addEventListener(\u0026#39;mouseup\u0026#39;, () =\u0026gt; { document.removeEventListener(\u0026#39;mousemove\u0026#39;, move) }) } el.addEventListener(\u0026#39;mousedown\u0026#39;, mouseDown); } // 鼠标坐标 const { x, y } = useMouse(); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; #box { width: 200px; height: 200px; background-color: rgb(238, 114, 114); } \u0026lt;/style\u0026gt; 封装的几种方式：setup()、选项式API、setup语法糖 插件\r#\r基础\r#\rreactive() 的局限性\r#\r参数只接受对象类型 Array Object Map Set 将属性赋值或解构到本地变量，或者传入一个函数时，会丧失响应性 原因：js没有作用域所有值类型的“引用” 解决：提供 ref() 为任何值类型的数据创建响应式，为 ref 对象包装一个.value属性 计算属性\r#\r\u0026lt;script setup\u0026gt; import { ref, reactive, computed } from \u0026#39;vue\u0026#39; const author = reactive({ name: \u0026#39;John Doe\u0026#39;, books: [ \u0026#39;Vue 2 - Advanced Guide\u0026#39;, \u0026#39;Vue 3 - Basic Guide\u0026#39;, \u0026#39;Vue 4 - The Mystery\u0026#39; ] }) // 返回一个计算属性 ref const publishedBooksMessage = computed(() =\u0026gt; { return author.books.length \u0026gt; 0 ? \u0026#39;Yes\u0026#39; : \u0026#39;No\u0026#39; }) const firstName = ref(\u0026#39;John\u0026#39;) const lastName = ref(\u0026#39;Doe\u0026#39;) const fullName = computed({ // getter get() { return firstName.value + \u0026#39; \u0026#39; + lastName.value }, // setter set(newValue) { // 注意：我们这里使用的是解构赋值语法 [firstName.value, lastName.value] = newValue.split(\u0026#39; \u0026#39;) } }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;Has published books:\u0026lt;/p\u0026gt; \u0026lt;span\u0026gt;{{ publishedBooksMessage }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; 侦听器\r#\rwatch() 和 watchEffect() 的区别：前者只监听的给定的数据源，后者自动监听回调中所有能访问的响应式属性 参数：侦听数据源、回调函数、其他选项（比如 immediate, deep, flush） 模板引用\r#\r访问模板引用：同名ref v-for 模板引用：ref 包含的是一个数组，对应整个列表的所有元素 函数模板引用：:ref=\u0026quot;(el) =\u0026gt; {}\u0026quot; 每次组件更新时都被调用 组件上的ref：可以获得组件实例，在下，父组件可以访问子组件暴露的变量和方法 "},{"id":5,"href":"/docs/vue/note4/","title":"Vue3和Vue2的区别","section":"Vue笔记","content":"盘点 Vue3 与 Vue2 的区别 - 掘金 （建议收藏）Vue3 对比 Vue2.x 差异性、注意点、整体梳理，与React hook比又如何？（面试热点） - 掘金\n组合式API\r#\r组合式API是一系列API的集合，使我们能够使用函数的方式书写组件，包括：\n响应式API：ref() reactive()等 生命周期钩子：onMounted() onUnmounted()等 依赖注入：provide() inject() setup() 钩子是在组件中使用组合式 API 的入口。在 setup() 函数中返回的对象会暴露给模板和组件实例。其他的选项也可以通过组件实例来获取 setup() 暴露的属性。 组合式API的优势\n更好的逻辑复用（组合函数等），解决了选项式API中 mixin 的缺陷，如（当使用多个mixin时，数据来源不清晰；不同 mixin 可能会注册相同的属性名，造成命名冲突；多个 mixin 之间相互作用，会隐形地耦合在一起） 更灵活的代码组织，选项式API中关于同一个逻辑的代码分散在各个选项中，要来回滚动，十分不便 更好的类型推导，支持TS 更小的打包体积 生命周期钩子\r#\rsetup替代了beforeCreate/ created beforeDestory/ destoryed 改名 beforeUnmount / unmounted beforeMount/ mounted / beforeUpdate / updated / beforeUnmount / unmounted 写在setup()里，并且加前缀on 多根节点\r#\r里面可以写多个根节点\nSuspense异步组件\r#\r允许程序在异步组件加载完之前渲染其他内容。 需要在 suspense 组件中，使用template模板声明，接收 #default 默认插槽和 #fallback 备用插槽。即List加载完成时显示自身（default），完成前显示Loading（fallback）。\n\u0026lt;tempalte\u0026gt; \u0026lt;suspense\u0026gt; \u0026lt;template #default\u0026gt; \u0026lt;List /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #fallback\u0026gt; \u0026lt;div\u0026gt; Loading... \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/suspense\u0026gt; \u0026lt;/template\u0026gt; Teleport组件\r#\r可将部分 DOM 移动到 Vue app 之外的位置。接收 to 和 disabled，其中 to 必填，指明目标容器，disabled 设为 true 时内容将保留在原始位置而不是移动到目标容器。\n\u0026lt;button @click=\u0026#34;dialogVisible = true\u0026#34;\u0026gt;显示弹窗\u0026lt;/button\u0026gt; \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;dialog\u0026#34; v-if=\u0026#34;dialogVisible\u0026#34;\u0026gt; 我是弹窗，我直接移动到了body标签下 \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt; TS支持\r#\r类型检查，便于阅读和维护。\n打包优化\r#\r借助模块的导入、导出，分析模块依赖关系，无需打包未使用的模块。\n响应式原理\r#\r使用proxy代替defineProperty。 defineProperty：直接在一个对象上定义新的属性或修改现有的属性，并返回对象。无法监听对象或数组新增、删除的元素。Vue2 相应解决方案：针对常用数组原型方法push、pop、shift、unshift、splice、sort、reverse进行了hack处理；提供Vue.set监听对象/数组新增属性。对象的新增/删除响应，还可以new个新对象，新增则合并新属性和旧对象；删除则将删除属性后的对象深拷贝给新对象。 proxy：创建对象的代理，从而实现基本操作的拦截和自定义操作。关注对象整体，不关心里面有什么属性。\nDiff算法\r#\r区分静态和动态节点，对静态节点进行提升，避免在每次渲染时重新创建。\n"},{"id":6,"href":"/docs/vue/note1/","title":"Vue响应式原理","section":"Vue笔记","content":"\rVue2\r#\rhttps://blog.csdn.net/weixin_58032613/article/details/122735346 https://blog.csdn.net/qq_41645323/article/details/123324680 vue中数据的双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。 数据劫持 通过Object.defineProperty()实现。 具体步骤：\n需要observer(观察者)对数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter。这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。 compile(模板解析器)解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 Watcher(订阅者)是Observer和Compile之间通信的桥梁，主要做的事情是: 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -\u0026gt; 视图更新；视图交互变化(input) -\u0026gt; 数据model变更的双向绑定效果。 Vue3 的变化\r#\r使用proxy代替defineProperty。 defineProperty：直接在一个对象上定义新的属性或修改现有的属性，并返回对象。无法监听对象或数组新增、删除的元素。Vue2 相应解决方案：针对常用数组原型方法push、pop、shift、unshift、splice、sort、reverse进行了hack处理；提供Vue.set监听对象/数组新增属性。对象的新增/删除响应，还可以new个新对象，新增则合并新属性和旧对象；删除则将删除属性后的对象深拷贝给新对象。 proxy：创建对象的代理，从而实现基本操作的拦截和自定义操作。关注对象整体，不关心里面有什么属性。\nVue2 为什么不能检测数组变动\r#\rhttps://segmentfault.com/a/1190000015783546\n监听数组\r#\rvue 能够监听数组变化的场景 vue 无法监听数组变化的场景 通过赋值的形式改变正在被监听的数组 通过数组索引改变数组元素的值 通过 splice(index, num, val) 的形式改变正在被监听的数组 改变数组的长度 通过数组的 push 的形式改变正在被监听的数组 无法监听数组变化的解决方案：\nthis.$set(arr, index, newVal)； 通过 splice(index，num，val)； 使用临时变量作为中转，重新赋值数组； 监听对象\r#\rvue 能够监听对象变化的场景 vue 无法监听对象变化的场景 直接赋值：watchObj = {name:\u0026ldquo;zyk\u0026rdquo;} 对象的增加、删除、修改无法被vue监听到 无法监听对象变化的解决方案：\n使用 this.$set(object, key, value)（vue 无法监听 this.$set 修改原有属性） 使用 Object.assign()，直接赋值 "},{"id":7,"href":"/docs/%E7%BD%91%E7%BB%9C/note1/","title":"前端跨域问题","section":"网络笔记","content":"\r跨域\r#\r跨域是指一个域下的文档或脚本去请求另一个域下的资源。通常说的跨域是指浏览器不能执行其他网站的脚本。它是浏览器同源策略造成的，是浏览器对JS实施的安全限制。\n同源策略\r#\r它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。同源策略限制以下行为：\nCookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送 三种思路\r#\r解除浏览器的跨域限制 发送JSON请求而不是xhr请求 修改服务器端（CORS） 解决方案\r#\rvue.config.js中proxy（代理，将浏览器的请求转发到服务器）\r#\r首先浏览器是禁止跨域的，但是服务端不禁止，在本地运行 npm run dev 等命令时实际上是用 node 运行了一个服务器，因此 proxyTable 实际上是将请求发给自己的服务器，再由服务器转发给后台服务器，做了一层代理。vue的proxyTable用的是http-proxy-middleware中间件, 因此不会出现跨域问题。\nCORS（第三种思路）\r#\r跨域资源共享 CORS 详解 - 阮一峰的网络日志\nJSONP（第二种思路）\r#\r利用script标签的src属性请求资源，缺点是只支持get请求。\nmac设置Chrome跨域（第一种思路）\r#\r原理：禁止浏览器进行跨域检查\n打开终端 运行命令：open -n /Applications/Google\\ Chrome.app/ \u0026ndash;args \u0026ndash;disable-web-security \u0026ndash;user-data-dir=/Users/zhongan/Documents/MyChromeDevUserData "},{"id":8,"href":"/docs/js/note2/","title":"手写函数","section":"JS笔记","content":"\rJS实现链表操作\r#\r// 定义节点 class Node { constructor(v) { this.value = v; this.next = null; } } // 创建链表 function createList(arr) { let list = new Node(null); let p = list; for (let data of arr) { p.next = new Node(data); p = p.next; } return list; } // 遍历链表 function traverseList(L) { let p = L.next; while(p) { console.log(p.value); p = p.next; } } // 获取链表长度 function getLen(L) { let res = 0; let p = L.next; while(p) { res += 1; p = p.next; } return res; } // 获取第i个元素值 function getElement(L, i) { let con = 0; let p = L.next; while(p) { con += 1; if (con === i) return p.value; p = p.next; } return null; } // 获取倒数第i个元素值 function getLastElement(L, i) { let p = L.next; let res = L.next; let dif = 0; while(p) { dif += 1; p = p.next; if(dif \u0026gt; i) res = res.next; } if (dif \u0026lt; i) return null; return res.value; } // 插入节点 function insertNode(L, position, value) { let p = L; let con = 0; while(p) { if (con === position) { let tmp = p.next; p.next = new Node(value); p.next.next = tmp; return true; } p = p.next; con += 1; } return false; } // 删除节点 function deleteNode(L, position) { let con = 0; let p = L.next; let prev = L; while(p) { if (con === position) prev.next = p.next; prev = prev.next; p = p.next; con += 1; } } // 有序链表合并 function mergeList(L1, L2) { let newL = new Node(null); let L = newL; let p = L1.next; let q = L2.next; while(p \u0026amp;\u0026amp; q) { if (p.value \u0026lt; q.value) { L.next = new Node(p.value); p = p.next; } else { L.next = new Node(q.value); q = q.next; } L = L.next; } while(p) { L.next = new Node(p.value); L = L.next; p = p.next; } while(q) { L.next = new Node(q.value); L = L.next; q = q.next; } return newL; } // 有序链表交集 function insertList(L1, L2) { let newL = new Node(null); let L = newL; let p = L1.next; let q = L2.next; while(p \u0026amp;\u0026amp; q) { if (p.value === q.value) { L.next = new Node(p.value); L = L.next; p = p.next; q = q.next; } else { if (p.value \u0026lt; q.value) { p = p.next; } else { q = q.next; } } } return newL; } let L = createList([1,2,3]); traverseList(\u0026#39;遍历链表\u0026#39;, L); console.log(\u0026#39;链表长度：\u0026#39;, getLen(L)); console.log(\u0026#39;第一个元素\u0026#39;, getElement(L, 1)); console.log(\u0026#39;第二个元素\u0026#39;, getElement(L, 2)); console.log(\u0026#39;第三个元素\u0026#39;, getElement(L, 3)); console.log(\u0026#39;第四个元素\u0026#39;, getElement(L, 4)); console.log(\u0026#39;倒数第一个元素\u0026#39;, getLastElement(L, 1)); console.log(\u0026#39;倒数第二个元素\u0026#39;, getLastElement(L, 2)); console.log(\u0026#39;倒数第三个元素\u0026#39;, getLastElement(L, 3)); console.log(\u0026#39;倒数第四个元素\u0026#39;, getLastElement(L, 4)); console.log(\u0026#39;倒数第四个元素\u0026#39;, getLastElement(L, 5)); // insertNode(L, 0, 10); // traverseList(L); // deleteNode(L, 1); // traverseList(L); let L2 = createList([1,3,6]); let newL = mergeList(L, L2); traverseList(newL); let newL1 = insertList(L, L2); traverseList(newL1); 数组拍平\r#\rfunction flat(arr, level) { if (level === 0) return [...arr]; let res = []; for (let a of arr) { if (Array.isArray(a)) { res = res.concat(flat(a, level - 1)); } else { res.push(a); } } return res; } console.log(flat([1, 2, [3, [4, 5]]], 0)); console.log(flat([1, 2, [3, [4, 5]]], 1)); console.log(flat([1, 2, [3, [4, 5]]], 2)); console.log(flat([1, 2, [3, [4, 5]]], 3)); JS创建二维数组\r#\r// 方法一 const arr = new Array(2).fill(0).map(() =\u0026gt; new Array(2).fill(0)); arr[0][0] = 1; // 正确 [ [ 1, 0 ], [ 0, 0 ] ] // 方法二(类似的for循环) const arr1 = new Array(); for(let i = 0; i \u0026lt; n; i++) { arr1.push([]); } JS字符串转数字\r#\r// 1. parseInt() 和 Number.parseInt() // 规则： // 1.忽略字符串前面的空格，直到找到第一个非空字符 // 2.如果第一个非空字符不是数字或者正负号，则返回NaN // 3.如果第一个是数字字符，一直解析到第一个非数字字符 // 4.如果第一个是数字字符，能识别不同进制的整数格式 // 5.接受第二个参数，即转换时使用的基数 // 6.小数向下取整 console.log(parseInt(true)); console.log(parseInt(false)); console.log(parseInt(null)); console.log(parseInt(undefined)); console.log(parseInt(NaN)); console.log(parseInt(\u0026#39; 123\u0026#39;)); console.log(parseInt(\u0026#39; a123\u0026#39;)); console.log(parseInt(\u0026#39; 123 4\u0026#39;)); console.log(parseInt(\u0026#39; 0xF\u0026#39;)); //16进制 console.log(parseInt(\u0026#39; 070\u0026#39;, 8)); //8进制 console.log(parseInt(0b10)); //2进制 console.log(parseInt(\u0026#39; A\u0026#39;, 16)); //16进制 // 2.parseFloat() // 规则： // 1.忽略字符串前面的空格，直到找到第一个非空字符 // 2.如果第一个非空字符不是数字或者正负号，则返回NaN // 3.如果第一个是数字字符，一直解析到第一个非数字字符 // 4.字符串中第一个小数点有效，第二个小数点无效 // 5.只解析10进制，不接受第二个参数 console.log(parseFloat(\u0026#39;123\u0026#39;)); console.log(parseFloat(\u0026#39;123.2\u0026#39;)); console.log(parseFloat(\u0026#39;ab123.2\u0026#39;)); console.log(parseFloat(\u0026#39;0xF\u0026#39;)); // 3.Number()构造函数 // 会返回一个字面量值，转化规则： // 如果是Boolean值，true和false分别返回1或0。 // 如果是数字，只是单纯的传入和返回。 // 如果是null，则返回0。 // 如果是undefined返回NaN。 // 如果是字符串且字符串为空则返回零，忽略前导零。 // 如果是字符串且字符串为整数则返回整数，忽略前导零。 // 如果是字符串且字符串为浮点数则返回浮点数。 // 如果是字符串且字符串为16进制，转为10进制返回。 // 除以上格式返回NaN。 // 如果是对象，则调用对象的valueOf，按照前面的规则返回值，如果返回NaN，再调用toString()，按照前面的规则返回值。 console.log(Number(true)); console.log(Number(false)); console.log(Number(123)); console.log(Number(null)); console.log(Number(undefined)); console.log(Number(NaN)); console.log(Number(\u0026#39;\u0026#39;)); console.log(Number(\u0026#39;123\u0026#39;)); console.log(Number(\u0026#39;123.1\u0026#39;)); console.log(Number(\u0026#39;0xA\u0026#39;)); // 4.位运算 // ~~ console.log(~~(true)); // 1 console.log(~~(false)); // 0 console.log(~~(null)); // 0 console.log(~~(undefined)); // 0 console.log(~~(NaN)); // 0 console.log(~~(\u0026#34;\u0026#34;)); // 0 console.log(~~(\u0026#34;123\u0026#34;)); // 123 console.log(~~(\u0026#34; 123\u0026#34;)); // 123 console.log(~~(\u0026#34;123.12\u0026#34;)); // 123 console.log(~~(\u0026#34;0xF\u0026#34;)); // 15 // \u0026lt;\u0026lt; console.log(true \u0026lt;\u0026lt; 0); // 1 console.log(false \u0026lt;\u0026lt; 0); // 0 console.log(null \u0026lt;\u0026lt; 0); // 0 console.log(undefined \u0026lt;\u0026lt; 0); // 0 console.log(NaN \u0026lt;\u0026lt; 0); // 0 console.log(\u0026#34;\u0026#34; \u0026lt;\u0026lt; 0); // 0 console.log(\u0026#34;123\u0026#34; \u0026lt;\u0026lt; 0); // 123 console.log(\u0026#34; 123\u0026#34; \u0026lt;\u0026lt; 0); // 123 console.log(\u0026#34;123.12\u0026#34; \u0026lt;\u0026lt; 0); // 123 console.log(\u0026#34;0xF\u0026#34; \u0026lt;\u0026lt; 0); // 15 // \u0026gt;\u0026gt; console.log(true \u0026gt;\u0026gt; 0); // 1 console.log(false \u0026gt;\u0026gt; 0); // 0 console.log(null \u0026gt;\u0026gt; 0); // 0 console.log(undefined \u0026gt;\u0026gt; 0); // 0 console.log(NaN \u0026gt;\u0026gt; 0); // 0 console.log(\u0026#34;\u0026#34; \u0026gt;\u0026gt; 0); // 0 console.log(\u0026#34;123\u0026#34; \u0026gt;\u0026gt; 0); // 123 console.log(\u0026#34; 123\u0026#34; \u0026gt;\u0026gt; 0); // 123 console.log(\u0026#34;123.12\u0026#34; \u0026gt;\u0026gt; 0); // 123 console.log(\u0026#34;0xF\u0026#34; \u0026gt;\u0026gt; 0); // 15 // 5.一元运算符 console.log(+(true)); // 1 console.log(+(false)); // 0 console.log(+(null)); // 0 console.log(+(undefined)); // NaN console.log(+(NaN)); // NaN console.log(+(\u0026#34;\u0026#34;)); // 0 console.log(+(\u0026#34;123\u0026#34;)); // 123 console.log(+(\u0026#34; 123\u0026#34;)); // 123 console.log(+(\u0026#34;123.12\u0026#34;)); // 123 console.log(+(\u0026#34;0xF\u0026#34;)); // 15 JS中的位运算\r#\rJavaScript的数字类型为双精度IEEE 754 64位浮点类型，但是在位运算中位运算符用于32位的数字上, 任何的数字操作都将转为32位, 运算结果再转化为Js数字类型。\n// \u0026amp; 按位与，可以用于判断奇偶性 console.log(7 \u0026amp; 1); console.log(8 \u0026amp; 1); // | 按位或，可以用来将值强制转换为32位整数类型 console.log(11.11 | 0); // 11 console.log(\u0026#34;11.11\u0026#34; | 0); // 11 console.log(\u0026#34;-11.11\u0026#34; | 0); // -11 console.log(1.23E2 | 0); // 123 console.log([] | 0); // 0 console.log(({}) | 0); // 0 // ^ 按位异或（相同为0，不同为1），可以用于交换数值 let a = 7; let b = 1; a ^= b; b ^= a; a ^= b; console.log(a); // 1 console.log(b); // 7 // 也可以借助数组 b = [a, a = b][0]; // 当然解构赋值更简单 [a, b] = [b, a]; // ~按位非 // ~~强制转换值为32位整数 console.log(~~(11.11)); // 11 console.log(~~(\u0026#34;11.11\u0026#34;)); // 11 console.log(~~(\u0026#34;-11.11\u0026#34;)); // -11 console.log(~~(1.23E2)); // 123 console.log(~~([])); // 0 console.log(~~({})); // 0 // \u0026lt;\u0026lt;左移 // \u0026gt;\u0026gt;有符号右移 // \u0026gt;\u0026gt;\u0026gt;无符号右移 JS创建对象的方式\r#\r// 字面量方式 var obj = { a: 1, b: {} } // Object构造函数 var obj = new Object(); obj.a = 1; obj.b = {}; // Object.create() var obj = Object.create(null); //创建一个没有原型链指向的对象 var obj = Object.create(Object.prototype); //等同于 new Object() // 工厂模式：构造创建对象的工厂，调用即产生对象，能够减少重复代码，减小代码冗余 function factory() { var o = new Object(); o.a = 1; o.b = {}; return o; } var obj = factory(); // 构造函数 function _object() { this.a = 1; this.b = {}; } var obj = new _object(); console.log(obj instanceof _object); // true // 原型模式 function _object1() {} _object1.prototype.a = 1; _object1.prototype.b = {}; var obj = new _object1(); console.log(obj); console.log(obj.a); console.log(obj.b); console.log(obj instanceof _object1); // true Object 对象的方法\r#\r复习一下遍历对象的方法： for in：用来遍历（对象自身+原型）可枚举属性 Object.keys()：遍历（对象自身）可枚举属性 Object.getOwnPropertyNames()：遍历（对象自身）可枚举属性+不可枚举属性 Object.getOwnPropertySymbols()：遍历（对象自身）Symbol属性 Reflect.ownKeys()：遍历（对象自身）可枚举属性+不可枚举属性+Symbol属性\n// Object.assign(target, ...sources) // 将一个或多个源对象的可枚举属性复制到目标对象上，返回目标对象的引用 // 拷贝方式是浅拷贝 console.log(\u0026#34;1.Object.assign()\u0026#34;); const s1 = {a: 1, c: { d: 2}}; const s2 = {b: 1}; const target = {}; Object.assign(target, s1, s2); // 地址拷贝，target的值随之改变，属于浅拷贝 s1.c.d = 3; // 值拷贝，target的值不会被影响 s1.a = 4; console.log(\u0026#39;修改后的s1\u0026#39;, s1); console.log(\u0026#39;修改后的target\u0026#39;, target); // Object.create(proto[, propertiesObject]) // 使用 proto 作为原型创建新的对象，可选参数是要添加到新对象上的不可枚举的属性描述符 console.log(\u0026#34;\\n2.Object.create()\u0026#34;); const proto = {a: 1, b: {c: 2}}; const newObj = Object.create(proto); console.log(\u0026#39;创建的新对象\u0026#39;, newObj); proto.a = 2; proto.b.c = 3; // 实现完整的浅拷贝 console.log(newObj.a); console.log(newObj.b.c); console.log(newObj.__proto__ === proto); // Object.is(val1, val2)判断两个值是否相同 /** * 两个值都是undefined * 两个值都是null * 两个值都是true或者都是false * 两个值是由相同个数的字符按照相同的顺序组成的字符串 * 两个值指向同一个对象 * 两个值都是数字并且，都是正零+0，都是负零-0，都是NaN * 都是除零和NaN外的其它同一个数字 */ console.log(\u0026#34;\\nObject.is()\u0026#34;); console.log(\u0026#39;Object.is(undefined, undefined)\u0026#39;, Object.is(undefined, undefined)); console.log(\u0026#39;Object.is(null, undefined)\u0026#39;, Object.is(null, undefined)); console.log(\u0026#39;Object.is(null, null)\u0026#39;, Object.is(null, null)); // Object.defineProperties(obj, props) // obj 对象 // props 定义或修改的属性描述符的对象 console.log(\u0026#34;\\n3.Object.defineProperties()\u0026#34;); const newObj1 = {}; Object.defineProperties(newObj1, { a: { value: 1, configurable: true, Writable: true, enumerable: true }, b: { value: 2, configurable: true, Writable: true, enumerable: true } }) console.log(newObj1); // 遍历可枚举属性 for (let i in newObj1) { //自身+原型上的可枚举属性 console.log(i); } // Object.defineProperty(obj, prop, descriptor) // obj 对象 // prop 定义或修改的属性描述符的对象 // descriptor 属性描述符对象 console.log(\u0026#34;\\n4.Object.defineProperty()\u0026#34;); // Object.entries(obj) // 返回一个给定对象obj 自身可枚举属性 的键值对数组，排列顺序与 for in 一致 console.log(\u0026#34;\\n5.Object.entries()\u0026#34;); // Object.values(obj) // 返回一个给定对象 自身的所有可枚举属性 值的数组 // Object.keys(obj) // 返回自身的可枚举属性的键 console.log(Object.keys(newObj1)); // Object.freeze(obj) // 冻结一个对象，不能添加、删除属性，不能修改属性配置和值，其原型也不能被修改 // 返回被冻结对象的引用 console.log(\u0026#34;\\n6.Object.freeze()\u0026#34;); const obj = {a: 1}; const freezeObj = Object.freeze(obj); console.log(\u0026#39;冻结前\u0026#39;, freezeObj); freezeObj.a = 2; console.log(\u0026#39;冻结后\u0026#39;, freezeObj); //打印{ a: 1 }，修改失败 // Object.isFrozen(obj) //判断一个对象是否被冻结 // Object.preventExtensions(obj) //让一个对象变的不可扩展，也就是永远不能再添加新的属性 // Object.isExtensible(obj) //判断一个对象是否是可扩展的 // Object.seal(obj) //封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置，当前属性的值只要原来是可写的就依旧可以改变 // Object.isSealed(obj) //判断一个对象是否被密封 // Object.fromEntries() // 把键值对列表(可迭代对象)转换为一个对象 console.log(\u0026#34;\\n7.Object.fromEntries()\u0026#34;); const arr = [[\u0026#39;a\u0026#39;, 1],[\u0026#39;b\u0026#39;, 2],[\u0026#39;c\u0026#39;, 3]] const newObj2 = Object.fromEntries(arr); console.log(\u0026#39;键值对列表转换结果\u0026#39;, newObj2); // Object.getOwnPropertyDescriptors() // 返回一个对象，由指定对象的所有自身属性的描述符组成，如果没有任何自身属性，则返回空对象 console.log(\u0026#34;\\n8.Object.getOwnPropertyDescriptors()\u0026#34;); const tar = {a: 1}; Object.defineProperty(tar, \u0026#39;key\u0026#39;, { // enumerable: false, value: 11, // writable: true }) const descriptor = Object.getOwnPropertyDescriptors(tar); console.log(descriptor); // Object.getOwnPropertyNames(obj) // 返回数组，由指定对象的自身属性的属性名组成（包括不可枚举属性），不包括symbol值作为名的属性，不包括原型上的属性 console.log(\u0026#34;\\n9.Object.getOwnPropertyNames(obj)\u0026#34;); // Object.getOwnPropertySymbols(obj) // 返回一个指定对象自身的所有Symbol属性的数组 console.log(\u0026#34;\\n10.Object.getOwnPropertySymbols(obj)\u0026#34;); // Object.setPrototypeOf(obj, prototype) // 设置一个指定的对象的原型即内部[[Prototype]]属性 // Object.getPrototypeOf(obj) // 返回指定对象的原型 console.log(\u0026#34;\\n11.Object.getPrototypeOf(obj)\u0026#34;); // 对象原型上的方法 // Object.prototype.hasOwnProperty(prop) 返回一个布尔值，判断对象自身属性是否具有指定的键 // Object.prototype.isPrototypeOf(object) 测试一个对象是否在另一个对象的原型链上 // Object.prototype.propertyIsEnumerable(prop) 返回一个布尔值，表示指定的属性是否可枚举 // Object.prototype.toLocaleString() 返回一个该对象的字符串表示 // Object.prototype.toString()方法返回一个表示该对象的字符串 // Object.prototype.valueOf()方法返回指定对象的原始值 Map与WeakMap、Set与WeakSet\r#\rMap与WeakMap：二者都用于保存键值对，其中Map中任意对象或原始值都可以作为键和值，WeakMap中键是弱引用的且必须为对象，值可以是任意对象或原始值。 Set与WeakSet：二者允许存储不重复的值，其中Set可以存储原始值或者对象引用，WeakSet只允许存储对象弱引用的唯一值。 弱引用：当弱引用对象没有其他引用时，垃圾回收机制就会释放该对象占用的内存，不需要手动删除引用。\nconsole.log(\u0026#34;===========\u0026gt;Map\u0026#34;); // 初始化 let m = new Map(); // 只读属性size，获取Map的键值对数量 console.log(m.size); // set(key, value) 设置键值对 m.set(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;); m.set(\u0026#34;key2\u0026#34;, \u0026#34;value2\u0026#34;); m.set(\u0026#34;key3\u0026#34;, \u0026#34;value3\u0026#34;); console.log(m.size); // has(key) // get(key) // delete(key) // clear() 清除map // Map是可迭代的 for (let item of m) { console.log(item); } for (let [key, value] of m.entries()) { console.log(key, value); } console.log(\u0026#34;===========\u0026gt;WeakMap\u0026#34;); let wm = new WeakMap(); let key = {name: \u0026#39;weakmap\u0026#39;} wm.set(key, \u0026#34;weakmap\u0026#34;); console.log(wm.has(key)); console.log(wm.get(key)); console.log(wm.delete(key)); console.log(\u0026#34;===========\u0026gt;Set\u0026#34;); let s = new Set(); s.add(1); s.add(2); console.log(s); console.log(s.has(1)); console.log(s.has(3)); // console.log(s.delete(2)); // console.log(s.delete(1)); s.forEach((n, b, s) =\u0026gt; { console.log(n, b, s); }) 源码（各自的属性与方法）\n/*! ***************************************************************************** Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. See the Apache Version 2.0 License for specific language governing permissions and limitations under the License. ***************************************************************************** */ /// \u0026lt;reference no-default-lib=\u0026#34;true\u0026#34;/\u0026gt; interface Map\u0026lt;K, V\u0026gt; { clear(): void; delete(key: K): boolean; forEach(callbackfn: (value: V, key: K, map: Map\u0026lt;K, V\u0026gt;) =\u0026gt; void, thisArg?: any): void; get(key: K): V | undefined; has(key: K): boolean; set(key: K, value: V): this; readonly size: number; } interface MapConstructor { new(): Map\u0026lt;any, any\u0026gt;; new\u0026lt;K, V\u0026gt;(entries?: readonly (readonly [K, V])[] | null): Map\u0026lt;K, V\u0026gt;; readonly prototype: Map\u0026lt;any, any\u0026gt;; } declare var Map: MapConstructor; interface ReadonlyMap\u0026lt;K, V\u0026gt; { forEach(callbackfn: (value: V, key: K, map: ReadonlyMap\u0026lt;K, V\u0026gt;) =\u0026gt; void, thisArg?: any): void; get(key: K): V | undefined; has(key: K): boolean; readonly size: number; } interface WeakMap\u0026lt;K extends object, V\u0026gt; { delete(key: K): boolean; get(key: K): V | undefined; has(key: K): boolean; set(key: K, value: V): this; } interface WeakMapConstructor { new \u0026lt;K extends object = object, V = any\u0026gt;(entries?: readonly [K, V][] | null): WeakMap\u0026lt;K, V\u0026gt;; readonly prototype: WeakMap\u0026lt;object, any\u0026gt;; } declare var WeakMap: WeakMapConstructor; interface Set\u0026lt;T\u0026gt; { add(value: T): this; clear(): void; delete(value: T): boolean; forEach(callbackfn: (value: T, value2: T, set: Set\u0026lt;T\u0026gt;) =\u0026gt; void, thisArg?: any): void; has(value: T): boolean; readonly size: number; } interface SetConstructor { new \u0026lt;T = any\u0026gt;(values?: readonly T[] | null): Set\u0026lt;T\u0026gt;; readonly prototype: Set\u0026lt;any\u0026gt;; } declare var Set: SetConstructor; interface ReadonlySet\u0026lt;T\u0026gt; { forEach(callbackfn: (value: T, value2: T, set: ReadonlySet\u0026lt;T\u0026gt;) =\u0026gt; void, thisArg?: any): void; has(value: T): boolean; readonly size: number; } interface WeakSet\u0026lt;T extends object\u0026gt; { add(value: T): this; delete(value: T): boolean; has(value: T): boolean; } interface WeakSetConstructor { new \u0026lt;T extends object = object\u0026gt;(values?: readonly T[] | null): WeakSet\u0026lt;T\u0026gt;; readonly prototype: WeakSet\u0026lt;object\u0026gt;; } declare var WeakSet: WeakSetConstructor; 函数柯里化\r#\r手动柯里化 // 柯里化的基本了解 // 通过闭包实现一个简单的柯里化函数 var add = function (x) { return function (y) { return x + y; } } console.log(add(1)(2)); console.log(add(1)(3)); console.log(add(1)(4)); // 箭头函数写法 var add2 = x =\u0026gt; y =\u0026gt; x+y; console.log(add2(3)(4)); // 柯里化案例一：打印日志 // 信息一：日志的时间 // 信息二：日志的类型 info/debug/feature // 信息三：日志的信息 // 1.没有柯里化的时候，每次都要传递三个参数 function logInfo(date, type, message) { console.log(`时间:${date} 类型:${type} 内容:${message}`); } logInfo(\u0026#39;2023-6-14\u0026#39;,\u0026#39;DEBUG\u0026#39;,\u0026#39;修复bug\u0026#39;) logInfo(\u0026#39;2023-6-14\u0026#39;,\u0026#39;DEBUG\u0026#39;,\u0026#39;又修复一个bug\u0026#39;) // 2.使用柯里化封装函数，只需传递每次不同的参数 var logInfo2 = date =\u0026gt; type =\u0026gt; message =\u0026gt; { console.log(`时间:${date} 类型:${type} 内容:${message}`); } var logToday = logInfo2(\u0026#39;2023-6-14\u0026#39;); var logDebug = logToday(\u0026#39;DEBUG\u0026#39;); var logFeature = logToday(\u0026#39;FEATURE\u0026#39;) logDebug(\u0026#39;修复bug1\u0026#39;); logDebug(\u0026#39;修复bug2\u0026#39;); logDebug(\u0026#39;修复bug3\u0026#39;); logFeature(\u0026#39;添加属性\u0026#39;); // 柯里化案例二：加法 var add = function (x) { // 保留参数x，返回接收剩余参数y的函数 return function (y) { return x + y; } } let adder1 = add(1); console.log(adder1(2)); console.log(adder1(3)); console.log(adder1(4)); 手写自动柯里化 function myCurrying(fn) { // args接收剩余参数 return function curryFn(...args) { // 判断当前参数数量是否大于等于fn的参数数量 // 大于等于：执行fn if (args.length \u0026gt;= fn.length) { // fn(...args); fn.apply(this, args); } // 否则：返回一个接收剩余参数的函数 else { return function (...newArgs) { // 在函数内部，拼接参数，递归 // return curryFn(...args, ...newArgs); return curryFn.apply(this, args.concat(newArgs)) } } } } function foo(x, y, z) { console.log(x + y + z); } var curryFoo = myCurrying(foo); var curry1 = curryFoo(10, 20); curry1(1); curryFoo(10)(20)(30); function logInfo(date, type, message) { console.log(`时间:${date} 类型:${type} 内容:${message}`); } var curryLogInfo = myCurrying(logInfo); var logToday = curryLogInfo(new Date()); logToday(\u0026#34;DEBUG\u0026#34;)(\u0026#39;修复一个错误\u0026#39;); JS中RegExp对象\r#\rRegExp.prototype.exec() 在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。 RegExp.prototype.test() 执行一个检索，用来查看正则表达式与指定的字符串是否匹配。 RegExp.prototype[@@match] 和 String.prototype.match() 会返回一个数组，它包括整个匹配结果，和通过捕获组匹配到的结果，如果没有匹配到则返回 null。 // 判断邮箱的正则表达式 var re = /^\\w+@(\\w+\\.)+\\w+$/g; var str = \u0026#39;yuanyuanhong@nuaa.edu.cn\u0026#39;; // 为了判断是否匹配 console.log(re.test(str)); // true // 为了找出所有匹配的字符串 /* 两个方法返回相同的结果： 会返回一个数组，它包括整个匹配结果，和通过捕获组匹配到的结果（保存在group属性中）； 如果没有匹配到则返回 null。 \u0026#39;abc\u0026#39;.match(/a/); /a/[Symbol.match](\u0026#39;abc\u0026#39;); */ console.log(str.match(re)); // [ \u0026#39;yuanyuanhong@nuaa.edu.cn\u0026#39; ] console.log(re[Symbol.match](str)); // [ \u0026#39;yuanyuanhong@nuaa.edu.cn\u0026#39; ] // 当正则表达式设置 g 标志位时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配 console.log(re.exec(str)); /* [ \u0026#39;yuanyuanhong@nuaa.edu.cn\u0026#39;, 匹配的结果 \u0026#39;edu.\u0026#39;, 捕获组结果 index: 0, input: \u0026#39;yuanyuanhong@nuaa.edu.cn\u0026#39;, groups: undefined ] */ Function与Object\r#\rJS中所有对象都来自Object，所有对象从Object.prototype继承方法和属性，尽管它们可能被覆盖，例如其他构造函数在原型中实现自己的toString()方法。Object原型对象的更改将传播到所有对象，除非这些受到更改的属性和方法沿原型链被覆盖。\n// 定义三个对象 var a = function(){} // 构造函数对象 var b = new Array(1); // 数组对象 var c = new Number(1); // 数字对象 // 包装对象 // 检查原型链 console.log(a.__proto__.__proto__ === Object.prototype); // true console.log(b.__proto__.__proto__ === Object.prototype); // true console.log(c.__proto__.__proto__ === Object.prototype); // true // 拆分指向 console.log(a.__proto__ === Function.prototype); // true console.log(Function.prototype.__proto__ === Object.prototype); // true console.log(b.__proto__ === Array.prototype); // true console.log(Array.prototype.__proto__ === Object.prototype); // true console.log(c.__proto__ === Number.prototype); // true console.log(Number.prototype.__proto__ === Object.prototype); // true // 使用instanceof 实际也是检测原型链 // instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 console.log(a instanceof Object); // true console.log(b instanceof Object); // true console.log(c instanceof Object); // true JavaScript中的所有的构造函数都继承自Function，包括Object构造函数，Function构造函数也继承于自己，当然Function也是继承于Object.prototype，可以说是先有的Object.prototype， Object.prototype构造出Function.prototype，然后Function.prototype构造出Object和Function。\n// 构造函数对象 var a = function(){} // 构造函数对象 // 检查原型链 console.log(a.__proto__ === Function.prototype); // true console.log(Object.__proto__ === Function.prototype); // true console.log(Function.__proto__ === Function.prototype); // true console.log(Function.prototype.__proto__ === Object.prototype); // true // 使用instanceof console.log(a instanceof Function); // true console.log(Object instanceof Function); // true console.log(Function instanceof Function); // true 总结：\n一切对象都继承于Object，都是从Object.prototype继承方法和属性。 一切构造函数包括Object与Function，都继承于Function，最终继承于Object Promise.race()改进，能够处理非promise\r#\r思路：每个promise用Promise.resolve()包裹，这样就可以捕获非promise的处理结果了。\nPromise.race = function (promises) { if (!Array.isArray(promises)) { return Promise.reject(\u0026#39;参数出错\u0026#39;); } return new Promise((resolve, reject) =\u0026gt; { for (let i = 0; i \u0026lt; promises.length; i++) { Promise.resolve(promises[i]) .then(res =\u0026gt; { resolve(res); }) .catch(err =\u0026gt; { reject(err); }) } }) } var promise1 = new Promise((resolve) =\u0026gt; { setTimeout(resolve, 1000, \u0026#39;promise1 成功\u0026#39;) }) var promise3 = new Promise((resolve, reject) =\u0026gt; { setTimeout(reject, 100, \u0026#39;promise3 失败\u0026#39;) }) // var promise4 = new Promise((resolve, reject) =\u0026gt; { reject(\u0026#39;promise4 失败\u0026#39;) }).catch(err =\u0026gt; console.log(err)) // 打印：promise3 失败 Promise.race([promise1, promise3]) .then(res =\u0026gt; console.log(res)) .catch(err =\u0026gt; console.log(err)) // 打印：成功的更快 Promise.race([Promise.resolve(\u0026#39;成功的更快\u0026#39;), promise3]) .then(res =\u0026gt; console.log(res)) .catch(err =\u0026gt; console.log(err)) // 打印：参数出错 Promise.race(1) .then(res =\u0026gt; console.log(res)) .catch(err =\u0026gt; console.log(err)) var p1 = 1; var p2 = new Error(\u0026#39;出错\u0026#39;) Promise.race([promise1, p2]) .then(res =\u0026gt; console.log(res)) .catch(err =\u0026gt; console.log(err)) 手写vue-router\r#\rVueRouter是一个构造函数，参数是路由配置{routes, mode}。根据参数获取路由配置和路由模式，然后根据路由模式监听首次加载和路由改变事件，获取到最新的路由值。 Vue.use()的作用：用来注册插件（限制重复注册），执行括号里面的方法（有install就执行install，没有就执行函数本身）。其中install方法的第一个参数是Vue的构造函数。 默认export default router为什么要暴露到main.js中，有什么作用？——将router放到根实例的$options中，为了让所有组件都可以拿到这个属性。（可以加到vue的原型链上） vue-router中的两个全局组件，router-link渲染成a标签，router-view通过获得当前url对应的组件并渲染 let Vue class VueRouter { constructor (options) { // console.log(options.routes); // 路由模式 this.mode = options.mode || \u0026#39;hash\u0026#39;; // 路由配置 this.routes = options.routes; // 用于保存最新的路由，使用了vue3的响应式 let initData = window.location.hash.slice(1) || \u0026#39;/\u0026#39;; Vue.util.defineReactive(this, \u0026#39;current\u0026#39;,initData) // this.current = \u0026#39;/\u0026#39;; this.init(); //监听路由 } init() { if (this.mode === \u0026#39;hash\u0026#39;) { // 首次加载 window.addEventListener(\u0026#39;load\u0026#39;, () =\u0026gt; { this.current = window.location.hash.slice(1); console.log(this.current); }) // 路由更新 window.addEventListener(\u0026#39;hashchange\u0026#39;, () =\u0026gt; { this.current = window.location.hash.slice(1) console.log(this.current); }) } } } VueRouter.install = function (_vue) { Vue = _vue; // 给vue添加全局组件和方法 Vue.mixin({ // 混入，比组件自身的声明周期调用更早 beforeCreate() { if (this.$options.router) { // 在根组件中拿到router，加到Vue实例上 Vue.prototype.$router = this.$options.router } } }) Vue.component(\u0026#39;router-link\u0026#39;,{ props: { to : { type: String, require: true } }, render(h) { return h(\u0026#39;a\u0026#39;,{ attrs: { href : \u0026#39;#\u0026#39; + this.to } }, // 获取组件内容 this.$slots.default) } }) Vue.component(\u0026#39;router-view\u0026#39;, { render(h) { console.log(this.$router); // $router已经被放到Vue原型上，所以在router-view组件中可以拿到 let current = this.$router.current; let routes = this.$router.routes; // 根据current获取对应组件 let router = routes.find(item =\u0026gt; item.path === current) console.log(router); return h(router.component) } }) } export default VueRouter JS遍历对象\r#\rconst obj = { name: \u0026#39;lcj\u0026#39;, age: 18, [Symbol()] : \u0026#39;symbol\u0026#39; } // 原型上的可枚举属性 Object.prototype.c = \u0026#39;我是原型上的属性\u0026#39; // 自身的不可枚举属性 Object.defineProperty(obj, \u0026#39;unenum\u0026#39;, { enumerable : false, value : \u0026#39;value\u0026#39; }) // for ... in ... 遍历对象（包括原型上的）所有可枚举属性，不按属性的顺序 console.log(\u0026#39;for in 遍历对象（包括原型上的）所有可枚举属性的值，不包括symbol:\u0026#39;); for (let i in obj) { console.log(obj[i]); } // Object.keys() 遍历对象自身所有可枚举属性，和 for in 遍历的顺序一样 console.log(\u0026#39;\\nObject.keys(obj)遍历对象自身所有可枚举属性的属性名，不包括symbol:\u0026#39;); var keys = Object.keys(obj); console.log(keys); // Object.getOwnPropertyNames() 遍历 console.log(\u0026#39;\\nObject.getOwnPropertyNames(obj)遍历对象自身所有属性的属性名（枚举+不可枚举），不包括symbol:\u0026#39;); var getOwnPropertyNames = Object.getOwnPropertyNames(obj); console.log(getOwnPropertyNames); // Object.getOwnPropertySymbols() 遍历 console.log(\u0026#39;\\nObject.getOwnPropertySymbols(obj)遍历对象自身所有 Symbol 属性的属性名:\u0026#39;); var getOwnPropertySymbols = Object.getOwnPropertySymbols(obj); console.log(getOwnPropertySymbols); // 获取对象自身属性，枚举 + 不可枚举 + Symbol： console.log(\u0026#39;\\nReflect.ownKeys(obj)遍历对象自身属性名，枚举 + 不可枚举 + Symbol\u0026#39;); var re = Reflect.ownKeys(obj); console.log(re); JS将多维数组转化为一维数组\r#\rvar arr = [1, [2, 3, [4, 5]]]; // 1.先转为字符串，再根据逗号分割 var res1 = arr.toString().split(\u0026#39;,\u0026#39;); var res2 = arr.join().split(\u0026#39;,\u0026#39;); console.log(res1); console.log(res2); // 2.递归 var res3 = []; getArr(arr); console.log(res3); function getArr(arr) { for (let a of arr) { if (Array.isArray(a)) { getArr(a); } else { res3.push(a); } } } // 3.concat 这种方法只能减少一个维度 var res4 = [].concat.apply(arr); console.log(res4); Promise方法学习\r#\rvar promise1 = new Promise((resolve) =\u0026gt; { setTimeout(resolve, 1000, \u0026#39;promise1 成功\u0026#39;)}) var promise2 = new Promise((resolve) =\u0026gt; { setTimeout(resolve, 100, \u0026#39;promise2 成功\u0026#39;) }) var promise3 = new Promise((resolve, reject) =\u0026gt; { setTimeout(reject, 100, \u0026#39;promise3 失败\u0026#39;) }) var promise4 = new Promise((resolve, reject) =\u0026gt; {reject(\u0026#39;promise4 失败\u0026#39;)}) /** * Promise.allSettled() * 接收promise数组 * 返回结果数组 * .then()接收结果的数组作为参数 */ // 打印： // [ // { status: \u0026#39;fulfilled\u0026#39;, value: \u0026#39;promise1 成功\u0026#39; }, // { status: \u0026#39;fulfilled\u0026#39;, value: \u0026#39;promise2 成功\u0026#39; }, // { status: \u0026#39;rejected\u0026#39;, reason: \u0026#39;promise3 失败\u0026#39; } // ] Promise.allSettled([promise1, promise2, promise3]).then(res =\u0026gt; console.log(res)) /** * Promise.all() * 接收Promise数组 * 若所有Promise成功，返回结果数组 * 若有一个Promise失败，立即返回失败结果： */ // 打印：\u0026#39;promise4 失败\u0026#39;（第一个抛出的失败信息） Promise.all([promise1, promise2, promise3, promise4]) .then(res =\u0026gt; console.log(res)) .catch(err =\u0026gt; console.log(err)) /** * Promise.any() * 当我们只需要一个 promise 兑现，而不关心是哪一个兑现时此方法很有用的。 * 接收Promise数组 * 若任意一个Promise成功，就返回第一个成功的结果： * 若都不成功，返回AggregateError，所有错误的结果： */ // 打印：promise2 成功（第一个成功的是promise2） Promise.any([promise1, promise2, promise3]).then(res =\u0026gt; console.log(res)) // 打印：[AggregateError: All promises were rejected] { // [errors]: [\u0026#39;promise3 失败\u0026#39;, \u0026#39;promise3 失败\u0026#39;] // } Promise.any([promise3, promise3]).catch(err =\u0026gt; console.log(err)) /** * Promise.race() * 给定的迭代中的一个 promise 解决或拒绝，就采用第一个 promise 的值作为它的值： */ // 打印：promise3 失败 Promise.race([promise1, promise3]).catch(err =\u0026gt; console.log(err)) // 打印：成功的更快 Promise.race([Promise.resolve(\u0026#39;成功的更快\u0026#39;), promise3]).then(res =\u0026gt; console.log(res)) 获取url参数\r#\rfunction getUrlParam(sUrl, sKey) { let parms = sUrl.split(\u0026#39;?\u0026#39;)[1].split(\u0026#39;#\u0026#39;)[0].split(\u0026#39;\u0026amp;\u0026#39;); var res = {}; for (let p of parms) { p = p.split(\u0026#39;=\u0026#39;); // console.log(p); if (res[p[0]] === undefined) res[p[0]] = []; res[p[0]].push(p[1]); } if (sKey !== \u0026#39;\u0026#39;) { return res[sKey] || \u0026#39;\u0026#39;; } return res; } var params = getUrlParam(\u0026#39;https://details/120288882?key=1\u0026amp;key=2\u0026amp;text=3\u0026amp;text=2\u0026amp;num=3#\u0026#39;, \u0026#39;num\u0026#39;); console.log(params); #\rasync/awit\r#\rasync函数 返回一个 Promise 对象，可以用 then()处理成功回调、catch()捕获异常。函数没有返回值的话默认会进入fullfilled状态：{ PromiseState: fullfilled, PromiseResult: undefined}。 function promise() { return new Promise((resolve, reject) =\u0026gt; { var rand = Math.random() * 2; setTimeout(() =\u0026gt; { resolve(`solve ${rand}`); }, 1000); }) } async function asyncPromise() { var result = await promise(); console.log(result); } var p = asyncPromise(); console.log(p); // p VM54:17 Promise {\u0026lt;pending\u0026gt;} [[Prototype]]: Promise [[PromiseState]]: \u0026#34;fulfilled\u0026#34; [[PromiseResult]]: undefined // result VM54:13 solve 0.7067351783995486 generator函数\r#\rfunction *f(x) { console.log(\u0026#39;第一次next()运行\u0026#39;); yield x + 10; console.log(\u0026#39;第二次next()运行\u0026#39;); yield x + 20; console.log(\u0026#39;第三次next()运行\u0026#39;); return x + 30; } var it = f(1); console.log(it); console.log(it.next()); console.log(it.next()); console.log(it.next()); console.log(it.next()); function* gen1(arg) { console.log(\u0026#39;打印参数：\u0026#39;, arg); let one = yield 111; //one被赋值为BBB console.log(\u0026#39;one=\u0026#39;, one); let two = yield 222; //two被赋值为CCC console.log(\u0026#39;two=\u0026#39;, two); let three = yield 333; //three被赋值为DDD console.log(\u0026#39;three=\u0026#39;, three); } let it1 = gen1(\u0026#39;AAA\u0026#39;); console.log(1, it1.next()); console.log(2, it1.next(\u0026#39;BBB\u0026#39;)); console.log(3, it1.next(\u0026#39;CCC\u0026#39;)); console.log(4, it1.next(\u0026#39;DDD\u0026#39;)); function* f1(x) { // 左边的y等待传参 var y = yield x + 10; console.log(y); let z = yield x + y; console.log(x, y, z); return x + 30; } var g = f1(1); console.log(g); // f {\u0026lt;suspended\u0026gt;} console.log(g.next()); // {value: 11, done: false} console.log(g.next(50)); // {value: 51, done: false} // y被赋值为50 console.log(g.next()); // {value: 31, done: true} // x,y 1,50 console.log(g.next()); // {value: undefined, done: true} new运算符\r#\r/** * new关键字 * * 语法：new constructor[([arguments])]，其中 * constructor 指定 对象实例类型 的 类或函数 * arguments 用于被constructor调用的参数列表 * * * new关键字的操作： * 1. 创建一个空对象 {} * 2. 为 步骤1 创建的对象添加属性 __proto__，指向构造函数的原型对象（这个对象就成为了构造函数的实例） * 3. 将 步骤1 创建的对象作为 this 上下文（使构造函数的this指针指向 步骤1 创建的对象，并传递参数） * 4. 若构造函数有返回对象，就返回该对象；否则返回 步骤1 创建的对象 * * * 代码实现： */ function _new(constructor, ...args) { const obj = {}; obj.__proto__ = constructor.prototype; let result = constructor.apply(obj, args); return typeof result === \u0026#34;object\u0026#34; ? result : obj; } function person(name, age) { this.name = name; this.age = age; } var lcj = _new(person,\u0026#39;lcj\u0026#39;, 18); console.log(lcj); JS遍历数组的方法\r#\rfor、forEach、map、for in、for of、every、some、find、findIndex、filter\n// for var arr1 = [1, 2, 3, 4, 5] for (let i=0, len = arr1.length; i \u0026lt; len; i++) { console.log(arr1[i]); } // for in 遍历数组效率非常低，主要是用来循环遍历对象的属性 // 数组遍历时需注意，数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同 // 不能保证for ... in将以任何特定的顺序返回索引 // for ... in循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些 // 因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素 // 因此当迭代访问顺序很重要的数组时，最好用整数索引去进行for循环 var arr1 = [1, 2, 3, 4, 5] for (let i in arr1) { console.log(arr1[i]); } var obj = {name: \u0026#39;lcj\u0026#39;} for (let i in obj) { console.log(obj[i]); } // for of // 在可迭代对象包括Array，Map，Set，String，TypedArray，arguments对象等等上 // 创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 var arr1 = [1, 2, 3, 4, 5] for (let item of arr1) { console.log(item); } // forEach 使用频率较高，但是性能不如普通for循环 // 可以添加第二个参数，指定回调函数的this，若回调函数是箭头函数则无效 var arr1 = [1, 2, 3, 4, 5] arr1.forEach(function (currentValue, currentIndex, array) { console.log(\u0026#39;当前值：\u0026#39;,currentValue); console.log(\u0026#39;当前下标：\u0026#39;,currentIndex); console.log(\u0026#39;遍历数组：\u0026#39;,array) console.log(\u0026#39;没有返回值\u0026#39;); } ) // map 回调函数return的结果组成了新数组的每一个元素，原数组被映射成对应新数组 // 可以添加第二个参数，指定回调函数的this，若回调函数是箭头函数则无效 var arr1 = [1, 2, 3, 4, 5] var arr2 = arr1.map(function (currentValue, currentIndex, array) { console.log(\u0026#39;当前值：\u0026#39;, currentValue); console.log(\u0026#39;当前下标：\u0026#39;, currentIndex); console.log(\u0026#39;遍历数组：\u0026#39;, array) console.log(\u0026#39;有返回值\u0026#39;); return currentValue + 1; } ) console.log(arr2); console.log(arr1); var arr = [1, 2, 3, 4, 5]; // arr.every(callback(currentValue [, index [, array]])[, thisArg]) // every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值 console.log(arr.every((currentValue) =\u0026gt; { return currentValue \u0026gt; 1; })) // false console.log(arr.every((currentValue) =\u0026gt; { return currentValue \u0026gt; 0; })) // true // arr.some(callback(element[, index[, array]])[, thisArg]) // some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值 console.log(arr.some((currentValue) =\u0026gt; { return currentValue \u0026gt; 1; })) // true console.log(arr.some((currentValue) =\u0026gt; { return currentValue \u0026gt; 6; })) // false // arr.find(callback(element[, index[, array]])[, thisArg]) // find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined console.log(arr.find((currentValue) =\u0026gt; { return currentValue \u0026gt; 2; })) // 3 console.log(arr.find((currentValue) =\u0026gt; { return currentValue \u0026gt; 6; })) // undefined // arr.findIndex(callback(element[, index[, array]])[, thisArg]) // findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引，否则返回-1 console.log(arr.findIndex((currentValue) =\u0026gt; { return currentValue \u0026gt; 2; })) // 2 console.log(arr.findIndex((currentValue) =\u0026gt; { return currentValue \u0026gt; 6; })) // -1 // arr.filter(callback(element[, index[, array]])[, thisArg]) // filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素 console.log(arr.filter((currentValue) =\u0026gt; { return currentValue \u0026gt; 2; })) // [3, 4, 5] apply、call、bind\r#\rfunction f(...args) { console.log(this.name, args); } const obj = { name: \u0026#39;lcj\u0026#39; } Function.prototype.myApply2 = function (obj) { obj.fn = this; let args = [...arguments][1] || []; let result = obj.fn(...args); delete obj.fn return result } f.myApply2(obj, [1, 2]); f.myApply2(obj, [1]); f.myApply2(obj); Function.prototype.myCall = function (obj) { obj.fn = this; let args = [...arguments].slice(1); let result = obj.fn(...args); delete obj.fn; return result; } f.myCall(obj, 1, 2); f.myCall(obj, 1); f.myCall(obj); Function.prototype.myBind = function (obj) { let fn = this; let args1 = [...arguments].slice(1); return function(...args2) { args1 = args1.concat(args2); return fn.call(obj,...args1); } } f.myBind(obj, 1, 3)(2, 4); f.myBind(obj)(); 手动实现Ajax\r#\rvar XMLHttpRequest = require(\u0026#39;xmlhttprequest\u0026#39;).XMLHttpRequest; function ajax(url, method = \u0026#34;GET\u0026#34;, data = null, async = true) { // 声明XMLHttpRequest //在IE5和IE6中需要使用ActiveX对象 // var XHR = XMLHttpRequest; // 创建XMLHttqRequest var XHR = new XMLHttpRequest() // 设置请求状态改变时执行的函数 XHR.onreadystatechange = function () { if (XHR.readyState === 4) console.log(`响应状态:${XHR.status}`, \u0026#34;FINISH\u0026#34;) //XHR.responseText为响应体 } // 初始化请求参数 XHR.open(method, url, async) // 发起请求 XHR.send(data) } ajax(\u0026#34;https://www.baidu.com\u0026#34;); ajax(\u0026#34;https://www.baidu.com\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;A=1\u0026amp;B=2\u0026#34;); // 自己写一个 var myXHR = new XMLHttpRequest(); myXHR.onreadystatechange = function () { if (myXHR.readyState == 4) { console.log(`请求成功，响应状态：${myXHR.status}`); } } myXHR.open(\u0026#39;GET\u0026#39;, \u0026#39;https://www.baidu.com\u0026#39;, true); myXHR.send(null) arguments对象转数组\r#\rfunction func1(a, b, c) { console.log(Array.prototype.slice.call(arguments)); console.log([...arguments]); console.log(Array.from(arguments)); } func1(1, 2, 3); 防抖和节流\r#\r// 非立即防抖： // 当持续触发事件的时候，事件处理函数是完全不执行的， // 等最后一次触发结束的一段时间之后，再去执行。 // 实现思路：每次触发事件时都取消之前的延时调用方法并重设定时器。 function debounce1(func, delay) { var timer = null; return function (...args) { clearTimeout(timer); timer = setTimeout(() =\u0026gt; { func(...args) }, delay); } } // 立即防抖： // 当持续触发事件的时候，事件处理函数会立即执行， // 然后不再执行事件处理函数，直至最后一次事件触发之后的一段时间后才允许再次执行事件处理函数。 // 实现思路：判断是否存在定时器，没有则执行事件处理函数， // 然后无论是否已经存在定时器都需要重设定时器。 function debounce2(func, delay) { var timer = null; return function (...args) { if (!timer) func(...args); clearTimeout(timer); timer = setTimeout(() =\u0026gt; { timer = null; }, delay); } } // 节流：判断是否存在定时器，没有则执行事件处理函数并重设定时器。 function throttle(func, delay, ...args) { var timer = null; return () =\u0026gt; { if (!timer) { func(...args); timer = setTimeout(() =\u0026gt; { timer = null; }, delay); } } } 深拷贝\r#\r原生方法实现深拷贝：主要是使用JSON.parse()与JSON.stringify()，首先将对象序列化为JSON字符串，再将JSON字符串反序列化为对象。\n// 原生方法实现深拷贝，JSON.parse 和 JSON.stringify function deepCopy(origin) { return JSON.parse(JSON.stringify(origin)); } const a = { name : \u0026#39;lcj\u0026#39; } var aCopy = deepCopy(a); a.name = \u0026#39;hyy\u0026#39;; console.log(a); console.log(aCopy); lodash.cloneDeep 库函数实现深拷贝\nvar _ = require(\u0026#39;lodash\u0026#39;); const b = { name: \u0026#39;lcj\u0026#39; } var bCopy = _.cloneDeep(b); b.name = \u0026#39;hyy\u0026#39;; console.log(b); console.log(bCopy); 浅拷贝\r#\r// 浅拷贝 // 手写方法：只复制第一层的浅拷贝 console.log(\u0026#39;手写方法实现浅拷贝\u0026#39;) function simpleCopy(obj1) { var obj2 = Array.isArray(obj1) ? [] : {}; for (let i in obj1) { obj2[i] = obj1[i]; } return obj2; } var obj1 = { a: 1, b: 2, c: { d: 3 } } var obj2 = simpleCopy(obj1); // 基本数据类型，拷贝值，修改拷贝数据不会影响原始数据 obj2.a = 3; obj2.b = 7; // 引用数据类型，拷贝内存地址，修改拷贝数据会影响原始数据 obj2.c.d = 4; // 打印结果 console.log(\u0026#39;obj1.a\u0026#39;,obj1.a); // 1 console.log(\u0026#39;obj2.a\u0026#39;,obj2.a); // 3 console.log(\u0026#39;obj1.b\u0026#39;,obj1.b); // 2 console.log(\u0026#39;obj2.b\u0026#39;,obj2.b); // 7 console.log(\u0026#39;obj1.c.d\u0026#39;,obj1.c.d); // 4 console.log(\u0026#39;obj2.c.d\u0026#39;,obj2.c.d); // 4 // 其他实现浅拷贝的方法 let a = [1] let arr = [4, 5, [6, 7]] let copy1 = arr.slice(0) let copy2 = a.concat(arr) console.log(\u0026#39;\\n数组方法实现浅拷贝\u0026#39;) // 基本数据类型，不会影响原始数据 arr[0] = \u0026#39;0\u0026#39; copy1[0] = \u0026#39;1\u0026#39; copy2[0] = \u0026#39;2\u0026#39; // 引用数据类型，拷贝内存地址，修改拷贝数据会影响原始数据 copy1[2][1] = 2 console.log(\u0026#39;arr\u0026#39;,arr) console.log(\u0026#39;copy1\u0026#39;,copy1) console.log(\u0026#39;copy2\u0026#39;,copy2) copy2[3][0] = 1 console.log(\u0026#39;arr\u0026#39;, arr) console.log(\u0026#39;copy1\u0026#39;, copy1) console.log(\u0026#39;copy2\u0026#39;, copy2) console.log(\u0026#39;\\nObject.assign实现浅拷贝\u0026#39;) // Object.assign(target, source_1, ···) let target = { a : 1 } let ob1 = { b : 2 } let ob2 = { c : { d : 3 } } Object.assign(target, ob1, ob2); console.log(\u0026#39;assign后的target：\u0026#39;,target) // target.b不会变 ob1.b = 4 console.log(\u0026#39;修改b后的target：\u0026#39;, target) // target.c.d会变 ob2.c.d = 5 console.log(\u0026#39;修改c.d后的target：\u0026#39;, target) console.log(\u0026#39;\\n拓展运算符实现浅拷贝\u0026#39;) let op1 = { a : 1, b : { c : 1 } } let op2 = {...op1} // op2.a没有被改变 op1.a = 2; console.log(\u0026#39;op1\u0026#39;, op1); console.log(\u0026#39;op2\u0026#39;, op2); // op2.b.c被改变 op1.b.c = 2; console.log(\u0026#39;op1\u0026#39;, op1); console.log(\u0026#39;op2\u0026#39;, op2); 数组排序\r#\r// 1.使用数组的方法sort() // 默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列时构建的 let values = [3, 2, 6, 11, 1, 19] // 从小到大(更简单的写法) values.sort((a, b) =\u0026gt; a - b) console.log(\u0026#39;sort从小到大：\u0026#39;, values) // 从大到小 values.sort((a, b) =\u0026gt; a \u0026lt;= b ? 1 : -1) console.log(\u0026#39;sort从大到小：\u0026#39;, values) // 2.冒泡排序 function bubbleSort(arr) { for (let i = 0; i \u0026lt; arr.length-1; i++) { // 优化：flag判断当前排序是否已经排好序，如果已经排好，就立即结束循环 let flag = true; for (let j = 0; j \u0026lt; arr.length-1-i ; j++) { if (arr[j] \u0026gt; arr[j+1]) { flag = false; let tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; } } if (flag) { break; } } return arr; } values = [3, 2, 6, 11, 1, 19] console.log(\u0026#39;冒泡排序：\u0026#39;, bubbleSort(values)) // 3.选择排序 function selectSort(arr) { for (let i = 0; i \u0026lt; arr.length-1; i++) { let index = i; for (let j = i+1; j \u0026lt; arr.length; j++) { if (arr[j] \u0026lt; arr[index]){ index = j; } } if (index != i) { let tmp = arr[index]; arr[index] = arr[i]; arr[i] = tmp; } } return arr; } values = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221] console.log(\u0026#39;选择排序：\u0026#39;, selectSort(values)) // 4.插入排序 function insertSort(arr) { for (let i = 1; i \u0026lt; arr.length; i++) { let j = i-1; let cur = arr[i]; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; cur) { arr[j+1] = arr[j]; j--; } arr[j+1] = cur; } return arr; } values = [3, 2, 6, 11, 1, 19] console.log(\u0026#39;插入排序：\u0026#39;, insertSort(values)) // 5.快速排序 function quickSort(arr) { if (arr.length \u0026lt; 2) { return arr; } // 取出数组的第一项 let middle = arr[0]; // 两个数组分别用来存 小于等于中间项 和 大于中间项 的值 let left = []; let right = []; for (let i = 1; i \u0026lt; arr.length; i++) { if (arr[i] \u0026lt;= middle) { left.push(arr[i]); } else if (arr[i] \u0026gt; middle) { right.push(arr[i]); } } // 递归并拼接数组 return quickSort(left).concat(middle, quickSort(right)) } values = [3, 2, 3, 6, 19, 11, 1, 19] console.log(\u0026#39;快速排序：\u0026#39;, quickSort(values)) values = [3, 2, 6, 11, 1, 19] console.log(\u0026#39;快速排序：\u0026#39;, quickSort(values)) values = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221] console.log(\u0026#39;快速排序：\u0026#39;, quickSort(values)) // 6.归并排序 // 7.堆排序 // 堆排序 function heapSort(arr) { let len = arr.length; // 从第一个非叶子节点往前，调整大顶堆 for (let i = Math.floor(len / 2); i \u0026gt;= 0; i--) { heapAdjust(arr, i, len); } for (let i = len-1; i \u0026gt;= 0; i--) { // 交换堆顶和对尾 let tmp = arr[i]; arr[i] = arr[0]; arr[0] = tmp; // 对堆顶进行调整 heapAdjust(arr, 0, i); } return arr function heapAdjust(arr, parent, end) { // arr 数组 // parent 当前调整的根节点 // end 堆的长度 // 左孩子下标 let child = parent * 2 + 1; // 当前根节点 let tmp = arr[parent]; while (child \u0026lt; end) { // 找两个孩子中的最大值 if (child + 1 \u0026lt; end \u0026amp;\u0026amp; arr[child + 1] \u0026gt; arr[child]) { child = child + 1; } // 比较父节点和孩子节点的大小，如果父节点大，结束循环 if (tmp \u0026gt;= arr[child]) { break; } // 如果孩子节点大，把更大的值放上来，然后继续向下寻找放tmp的位置 arr[parent] = arr[child]; parent = child; child = parent * 2 + 1; } // 没有孩子节点了，或者孩子节点都小，找到放tmp的位置 arr[parent] = tmp; } } values = [3, 2, 3, 6, 19, 11, 1, 19] console.log(\u0026#39;堆排序：\u0026#39;, heapSort(values)) values = [3, 2, 6, 11, 1, 19] console.log(\u0026#39;堆排序：\u0026#39;, heapSort(values)) values = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221] console.log(\u0026#39;堆排序：\u0026#39;, heapSort(values)) // 归并排序 function mergeSort(arr) { if (arr.length \u0026lt;= 1) { return arr; } // 中间下标 let mid = Math.floor(arr.length / 2); // 左边排序 let arr1 = mergeSort(arr.slice(0, mid)); // 右边排序 let arr2 = mergeSort(arr.slice(mid)); // 合并有序数组 return mergeArray(arr1, arr2); // 合并两个已经排序的数组 function mergeArray(arr1, arr2) { let res = []; let ll = 0,lr = 0; while (ll \u0026lt; arr1.length \u0026amp;\u0026amp; lr \u0026lt; arr2.length) { if (arr1[ll] \u0026lt;= arr2[lr]) { res.push(arr1[ll]); ll++; } else { res.push(arr2[lr]); lr++; } } while (ll \u0026lt; arr1.length) { res.push(arr1[ll]); ll++; } while (lr \u0026lt; arr2.length) { res.push(arr2[lr]); lr++; } return res; } } values = [3, 2, 3, 6, 19, 11, 1, 19] console.log(\u0026#39;归并排序：\u0026#39;, mergeSort(values)) values = [3, 2, 6, 11, 1, 19] console.log(\u0026#39;归并排序：\u0026#39;, mergeSort(values)) values = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221] console.log(\u0026#39;归并排序：\u0026#39;, mergeSort(values)) instanceOf原理\r#\rlet person = function () { } let no = new person() console.log(no instanceof person) function new_instance_of(leftValue, rightVaule) { let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值 leftValue = leftValue.__proto__; // 取左表达式的__proto__值 while (leftValue) { if (leftVaule === rightProto) { return true; } leftValue = leftValue.__proto__ } return false; } console.log(new_instance_of(no, person)) vue数组响应式方法\r#\rbtnClick(){ // 1.push()方法：可以同时添加多个元素，可以传入多个值 // this.letters.push(\u0026#39;aaa\u0026#39;) // 2.pop()：删除数组中的最后一个元素 // this.letters.pop() // 3.shift()：删除数组中的第一个元素 // this.letters.shift() // 4.unshift()：在数组最前面添加元素(可以添加多个) // this.letters.unshift(\u0026#39;aaa\u0026#39;) // 5.splice() 删除元素/插入元素/替换元素 // 删除元素：第二个参数传入要删除几个元素（如果没有传，就删除后面所有的元素） // this.letters.splice(2,2) // 替换元素：第二个参数表示要替换几个元素，后面是用于替换前面的元素 // this.letters.splice(1,3,\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;l\u0026#39;) // 插入元素：第二个参数传入0，并且后面跟上要插入的元素 // this.letters.splice(2,0,\u0026#39;k\u0026#39;) // 6.sort()排序 // this.letters.sort() // 7.reverse()翻转 // this.letters.reverse() //注意：通过索引值修改数组中的元素，不是响应式的 // this.letters[0] = \u0026#39;bbb\u0026#39; } CSS画三角形\r#\r\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 使用 border */ .box:first-child { width: 0; height: 0; border: 100px solid transparent; /* border-right: 100px solid gray; */ border-bottom: 100px solid gray; } /* 使用线性渐变 linear-gradient */ .box:nth-child(2) { width: 100px; height: 100px; background: linear-gradient(45deg, deeppink, deeppink 50%, transparent 50%,transparent 100%); } /* 使用 transform: rotate 配合 overflow: hidden */ .box:nth-child(3) { width: 141px; height: 100px; position: relative; overflow: hidden; } .box:nth-child(3)::before { content: \u0026#34;\u0026#34;; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: deeppink; /* 旋转的点是左上角 */ transform-origin: left top; transform: rotate(45deg); } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 盒子水平居中\r#\r.father1 { /* flex布局 */ /* display: flex; justify-content: center; align-items: center; */ /* grid布局 */ display: grid; justify-content: center; align-content: center; margin-bottom: 10px; width: 300px; height: 300px; background-color: pink; } .son1 { width: 100px; height: 100px; background-color: #fff; } .father2 { margin-bottom: 10px; width: 300px; height: 300px; background-color: pink; } .son2 { /* 相当于 position: relative; top: calc(50% - 高度一半); left: calc(50% - 宽度一半);*/ /* 或者 */ position: relative; top: 50%; margin:0 auto; transform: translateY(-50%); /* 或者 */ /* position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); */ width: 100px; height: 100px; background-color: #fff; } .father3 { position: relative; margin-bottom: 10px; width: 300px; height: 300px; background-color: pink; } .son3 { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; background-color: #ccc; } .father4 { width: 300px; height: 300px; background-color: pink; } .son4 { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; background-color: pink; } 三栏布局\r#\rflex \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .container { display: flex; height: 200px; margin: 0 auto; } div \u0026gt; .left { width: 200px; background-color: burlywood; } div \u0026gt; .right { width: 200px; background-color: royalblue; } div \u0026gt; .main { /* flex布局 */ flex: 1; background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;left\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt;main\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;right\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; calc：通过CSS的calc可以动态计算中间部分的长度从而做到自适应，calc可以配合inline-block行内块级元素实现三栏布局，注意使用行内块级元素的时候如果编写HTML时换行，这个空白的换行也会作为元素解析从而会产生空白间隙，所以在编写时此处不要换行 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .container { /* display: flex; */ height: 200px; /* margin: 0 auto; */ } .container \u0026gt; div{ display: inline-block; height: 100%; color: #fff; } div \u0026gt; .left { width: 200px; background-color: burlywood; } div \u0026gt; .right { width: 200px; background-color: royalblue; } div \u0026gt; .main { /* flex布局 */ /* flex: 1; */ /* calc设置宽度 */ width: calc(100% - 400px); background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;left\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt;main\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;right\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; margin+float：使左右模块各自向左右浮动，并设置中间模块的margin值使中间模块宽度自适应。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Margin\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .container { height: 200px; border: 1px solid #eee; } .container div { color: #fff; height: 100%; } .container\u0026gt;.left { float: left; width: 200px; background-color: #19be6b; } .container\u0026gt;.main { margin-left: 200px; margin-right: 200px; background-color: #2979ff; } .container\u0026gt;.right { float: right; width: 200px; background-color: #fa3534; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;left\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;right\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt;main\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; "},{"id":9,"href":"/docs/vue/","title":"Vue笔记","section":"Docs","content":"\rVue笔记，等待完善ing\r#\r"},{"id":10,"href":"/docs/vue/note2/","title":"Vue组合式API","section":"Vue笔记","content":" 组合式API是一系列API的集合，使我们能够使用函数的方式书写组件，包括：\n响应式API：ref() reactive()等 生命周期钩子：onMounted() onUnmounted()等 依赖注入：provide() inject() setup() 钩子是在组件中使用组合式 API 的入口。在 setup() 函数中返回的对象会暴露给模板和组件实例。其他的选项也可以通过组件实例来获取 setup() 暴露的属性。\nsetup()\r#\rsetup() 函数是最早执行的，只执行一次，接收参数 组件的props 和 上下文context，返回 data 和 method。 props 是响应式的，为了在解构 props 时仍保持响应性，可以在 setup() 函数中使用 toRefs() 函数。 context 是普通对象，非响应式的。包含三个属性： attrs：接收父组件传递过来的，并且没有在props中声明的参数。 emit：用来在子组件中对父组件发送事件。在vue2中，子对父发送事件采用this.$emit；在vue3中，子组件对父组件发送事件采用 context.emit。 slots：（这个不太懂）。 响应式：核心\r#\rref()\r#\rhttps://juejin.cn/post/7225474899481051173\n用于将基本数据类型包装成响应式对象，ref是使用class里的get/set进行数据劫持和更新的。 .value 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。 在setup()里访问时，要加.value。从setup()里返回后，在模板里使用会自动解包，但是深层次的数据还是需要加.value才能访问。 reactive()\r#\r接收对象数据类型，使其成为响应式数据。\n响应式对象内的ref属性会被解包；响应式数组或 Map 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包： const count = ref(1) const obj = reactive({ count }) // ref 会被解包 console.log(obj.count === count.value) // true const books = reactive([ref(\u0026#39;Vue 3 Guide\u0026#39;)]) // 这里需要 .value console.log(books[0].value) const map = reactive(new Map([[\u0026#39;count\u0026#39;, ref(0)]])) // 这里需要 .value console.log(map.get(\u0026#39;count\u0026#39;).value) reactive的缺陷：\n参数只接受对象类型 Array Object Map Set 将属性赋值或解构到本地变量，或者传入一个函数时，会丧失响应性 原因：js没有可以作用域所有值类型的“引用” 解决：提供 ref() 为任何值类型的数据创建响应式，为 ref 对象包装一个.value属性 watch()\r#\r三个参数：侦听的响应式引用或getter函数、回调函数、配置选项（比如 immediate, deep, flush） 具有一定的惰性lazy，第一次页面展示的时候不会执行，只有数据变化的时候才会执行 只监听的给定的数据源 参数可以拿到当前值和原始值 watchEffect(副作用函数, 配置选项)\r#\r立即执行，没有惰性，页面的首次加载就会执行 不需要传递要侦听的内容 会自动感知代码依赖，不需要传递很多参数，只要传递一个回调函数 自动监听回调中所有能访问的响应式属性 只能获取当前值，不能获取之前数据的值 computed()\r#\r// 1.选项式写法 let firstName = ref(\u0026#34;yy\u0026#34;); let lastName = ref(\u0026#34;h\u0026#34;); let name = computed({ get() { return firstName.value + \u0026#34;-\u0026#34; + lastName.value; }, set(newVal) { [firstName.value, lastName.value] = newVal.split(\u0026#34;-\u0026#34;); }, }); const changeName = () =\u0026gt; { name.value = \u0026#34;l-cj\u0026#34;; }; // 2.函数式写法 let name1 = computed(() =\u0026gt; firstName.value + \u0026#34;-\u0026#34; + lastName.value); readonly()\r#\r接受一个对象 (响应式或纯对象) 或 ref 并返回原始对象的只读代理，不能修改只读副本。只读代理是深层的：任何被访问的嵌套 property 也是只读的。\nwatchPostEffect()\r#\rwatchEffect() 使用 flush: \u0026lsquo;post\u0026rsquo; 选项时的别名。\nwatchSyncEffect()\r#\rwatchEffect() 使用 flush: \u0026lsquo;sync\u0026rsquo; 选项时的别名。\n响应式：工具\r#\risRef()\r#\r检查某个值是否为 ref。\nunRef()\r#\r如果参数是 ref，则返回内部值，否则返回参数本身。\ntoRef()\r#\r可以将值、refs 或 getters 规范化为 refs。 在一个响应式对象里面，想把其中一个属性拿出来单独做响应式，可以使用toRef(obj, attrName)。\n用于响应式对象，修改响应式数据会影响到原始数据。 如果用于普通对象，则不具备响应式（数据的值改变了，但是视图不会变化）。 和ref的区别：ref本质是拷贝，修改响应式数据不会影响原始数据；toRef的本质是引用关系，修改响应式数据会影响原始数据。 toValue()\r#\r将值、refs 或 getters 规范化为值。\ntoRefs()\r#\r当需要解构响应式对象，且希望解构后的对象也保持响应性是，可以使用toRefs(reactiveObj)。\nisProxy()\r#\r检查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理。\nisReactive()\r#\r检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理。\nisReadonly()\r#\r检查传入的值是否为只读对象。只读对象的属性可以更改，但他们不能通过传入的对象直接赋值。\n响应式：进阶\r#\r响应式 API：进阶 | Vue.js\n生命周期钩子\r#\r组合式 API：生命周期钩子 | Vue.js\n注入依赖\r#\r组合式 API：依赖注入 | Vue.js onRenderTracked() 状态跟踪，会跟踪页面上所有响应式变量和方法的状态 onRenderTriggered() 状态触发，只有值变化时会触发该回调函数，明确给出新值和旧值\nprovide() \u0026amp; inject()\r#\r父级组件使用provide向下进行传递数据。 子级组件使用inject来获取上级组件传递过来的数据。 "},{"id":11,"href":"/docs/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/note2/","title":"其他工具","section":"开发工具","content":"\rdocker\r#\r一个容器管理工具 目标：有基础了解，知道这是个啥，干嘛用的 功能：将各种应用程序和他们所依赖的运行环境打包成标准的容器，容器之间隔离\nimage container registry 教程：\ndocker入门教程——by阮一峰 docker与虚拟机的区别，docker基本命令 Nginx\r#\r作为一个响应更快和并发更高的（高性能）HTTP和反向代理web服务器，能够提供邮件服务。 目标：基于http /server块的常用属性及基础配置做一下了解 功能：代理、反向代理、负载均衡（轮询、加权轮询、ip hash）、动静分离 特点：内存小，并发能力强 配置文件nginx.config：\n全局配置 event配置 http：http全局配置，静态资源文件等 server配置：在http下面可以配置多个server，进行代理等 负载均衡配置 http { upstream hyy { // 负载均衡配置 // 服务器资源 server xxx.xxx.xxx.xxx weight=1;\t//权重 server xxx.xxx.xxx.xxx weight=1; } server { listen 80;\t//监听端口 server_name localhost; // 访问80端口的根目录，就会到location中 location / { // xxxx 128服务器 root html; index index.html; // 反向代理 proxy_pass http://hyy; } // 访问admin location /admin { // xxxx 47服务器 } } } 使用：\n在cmd运行：nginx.exe 每当配置文件变化，重新加载：nginx -s reload 配置：\nnginx Nginx 配置详解_白墨石的博客-CSDN博客 Nginx配置文件详解 - 程序员自由之路 - 博客园 Shell\r#\rShell 是一个应用程序，连接用户和 Linux 内核，交互模式（命令行）和非交互模式（执行shell脚本）。 目标：shell 干什么的，有基础印象 介绍：\nShell是什么？1分钟理解Shell的概念！ 一篇文章让你彻底掌握 shell 语言 - 静默虚空 - 博客园 "},{"id":12,"href":"/docs/js/note1/","title":"函数柯里化和Promise","section":"JS笔记","content":"\r手写自动柯里化函数\r#\rfunction myCurrying(fn) { // args接收剩余参数 return function curryFn(...args) { // 判断当前参数数量是否大于等于fn的参数数量 // 大于等于：执行fn if (args.length \u0026gt;= fn.length) { // fn(...args); fn.apply(this, args); } // 否则：返回一个接收剩余参数的函数 else { return function (...newArgs) { // 在函数内部，拼接参数，递归 // return curryFn(...args, ...newArgs); return curryFn.apply(this, args.concat(newArgs)) } } } } function foo(x, y, z) { console.log(x + y + z); } var curryFoo = myCurrying(foo); var curry1 = curryFoo(10, 20); curry1(1); curryFoo(10)(20)(30); function logInfo(date, type, message) { console.log(`时间:${date} 类型:${type} 内容:${message}`); } var curryLogInfo = myCurrying(logInfo); var logToday = curryLogInfo(new Date()); logToday(\u0026#34;DEBUG\u0026#34;)(\u0026#39;修复一个错误\u0026#39;); Promise再学习！\r#\r理解\r#\rPromise是异步编程的解决方案（ES6）。从语法上看Promise是一个构造函数，从功能上看Promise封装异步操作并返回成功/失败的结果。 异步编程包括： fs 文件操作 数据库操作 AJAX 定时器 为什么要用Promise\r#\r支持链式调用，可以解决回调地狱问题（回调地狱层级太多，不便于阅读和错误处理） 指定回调函数的方式更加灵活（Promise启动异步任务=\u0026gt;返回Promise对象=\u0026gt;给Promise对象绑定回调函数） "},{"id":13,"href":"/docs/%E7%BD%91%E7%BB%9C/","title":"网络笔记","section":"Docs","content":"\r网络笔记，等待完善ing\r#\r"},{"id":14,"href":"/docs/js/note3/","title":"JS内置对象Array（一）","section":"JS笔记","content":"\r特征\r#\rJS数组大小是可以动态调整的（通过length属性），可以包含不同的数据类型 JS数组只能通过非负整数（和对应的字符串形式）作为索引访问 JS数组索引从0开始，最后一个元素索引是length-1 JS数组的复制操作会创建浅拷贝（所以JS对象的标准复制操作都会创建浅拷贝） 创建数组\r#\r构造函数 new Array()\n会根据传入的参数创建数组 当仅有一个参数arrayLength且为数字时，会创建arrayLength个空槽组成的数组 可以不使用new关键字 字面量 []\nconst fruits = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;]; 字符串对象原型上的方法 String.prototype.split()\nconst fruits3 = \u0026#34;Apple, Banana\u0026#34;.split(\u0026#34;, \u0026#34;); 创建二维数组\r#\r// 方法一 const arr = new Array(2).fill(0).map(() =\u0026gt; new Array(2).fill(0)); arr[0][0] = 1; // 正确 [ [ 1, 0 ], [ 0, 0 ] ] // 方法二(类似的for循环) const arr1 = new Array(); for(let i = 0; i \u0026lt; n; i++) { arr1.push([]); } 属性\r#\r原型 Array.prototype 上的属性：Array.prototype.constructor\n创建实例对象的构造函数 对于 Array 实例，初始值是 Array 构造函数。 实例自身的属性：length\n是Array的实例属性，反映数组中元素的数量 可修改 当length小于当前长度的值，超过length的元素会被删除 当length大于当前长度的值，将会用空槽拓展数组 当length属性为无效值，会引发RangeError 静态方法\r#\rArray.isArray()\n参数：一个值。 返回值：true或者false。用于确定传递的值是否是一个 Array。 Array.isarray() 拒绝原型链中带有 Array.prototype，而实际不是数组的对象，但 instanceof Array 会接受。判断一个变量是不是数组，最方便的方法是Array.isArray()\nArray.from(arrayLike [, mapFn, thisArg])\n参数：可迭代或类数组对象。可选参数是map函数和this上下文。 返回值：一个新的浅拷贝的数组实例。 Array.of()\n参数：可变数量的值。 返回值：一个新的 Array 实例，不考虑参数的数量或类型。 Array.of() 和 Array() 构造函数之间的区别在于对单个参数的处理：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个 length 为 7 的空数组（这意味着一个由 7 个空槽组成的数组，而不是由 7 个 undefined 组成的数组）。\n实例方法\tArray - JavaScript | MDN\r#\rArray.prototype.at(index)\n参数：索引值。接受负整数，从数组末尾开始计数，-1表示数组最后一个元素的索引。 返回值：给定索引处的数组元素。 如果 index \u0026lt; -array.length 或 index \u0026gt;= array.length，则总是返回 undefined。 Array.prototype.concat()\n参数：0个或多个数组。 返回值：一个新数组。 该数组将首先由调用它的对象中的元素填充。然后，对于每个参数，它的值将被连接到数组中——对于普通对象或基元，参数本身将成为最终数组的一个元素。concat方法是一种复制方法，返回浅拷贝。 Array.prototype.sort()\n对数组的元素进行排序，并返回对相同数组的引用。默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。由于它取决于具体实现，因此无法保证排序的时间和空间复杂度。 v8排序源码解析\n当数组长度小于等于10，采用插入排序。复杂度n^2。 大于10采用快排。通过对关键值的选取，能最大程度保证快排的复杂度趋近于平均复杂度，即nlogn。 "},{"id":15,"href":"/docs/%E7%BB%84%E4%BB%B6%E5%BA%93/","title":"组件库笔记","section":"Docs","content":"\r组件库笔记，等待完善ing\r#\r"},{"id":16,"href":"/docs/hugo/","title":"Hugo笔记","section":"Docs","content":"\rHugo笔记，等待完善ing\r#\r"},{"id":17,"href":"/docs/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/","title":"开发工具","section":"Docs","content":"\r网络笔记，等待完善ing\r#\r"},{"id":18,"href":"/docs/","title":"Docs","section":"","content":""},{"id":19,"href":"/menu/","title":"Menu","section":"","content":"JS笔记 -[JS笔记]({{ \u0026lt;relref \u0026ldquo;/docs/JS\u0026rdquo;\u0026gt;}})\n函数柯里化和Promise "}]